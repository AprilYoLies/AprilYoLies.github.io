<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Java 后端">
    <meta name="description" content="小橘子🍊的个人主页，欢迎访问~~">
    <meta name="author" content="小橘子🍊">
    
    <title>
        
            Spring事务机制实现原理 |
        
        AprilYoLies
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://img.aprilyolies.top/img/typora/avatar.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"aprilyolies.top","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"https://img.aprilyolies.top/img/typora/avatar.jpg","favicon":"https://img.aprilyolies.top/img/typora/avatar.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"干燥的空气，尘埃的味道，我在其中…踏上旅途！"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://img.aprilyolies.top/img/typora/avatar.jpg">
                </a>
            
            <a class="logo-title" href="/">
                AprilYoLies
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Spring事务机制实现原理</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="https://img.aprilyolies.top/img/typora/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">小橘子🍊</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2019-07-22 20:44:44</span>
        <span class="mobile">2019-07-22 20:44</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Spring/">Spring</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我的上一篇文章中已经比较详细的对 Spring 的 AOP 实现原理进行了说明，而 Spring 的事务实现原理呢又跟 Spring 的 AOP 实现有着较大的关系，所以这里选择成热打铁，对 Spring 的事务实现机制进行一下说明。上一篇文章在对 AOP 实现进行解释时，只分析了它的 cglib 代理实现，因为提供的例子中被代理类没有实现相应的接口，导致不能通过 jdk 原生方式进行代理，而本文将要解释的 Spring 事务实现中，例子是实现了用户服务接口的，所以代理方式是采用的 jdk 原生方式，正好能够对上文进行补充。同样的示例代码我已经提交到我的 <a class="link"   target="_blank" rel="noopener" href="https://github.com/AprilYoLies/spring-framework" >github<i class="fas fa-external-link-alt"></i></a> 上，欢迎自取。在阅读本文之前，十分的建议先看我的上一篇 <a class="link"   target="_blank" rel="noopener" href="https://www.aprilyolies.top/2019/07/21/Spring-AOP-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" >Spring AOP 实现原理<i class="fas fa-external-link-alt"></i></a>文章，因为分析 Spring 事务实现原理的方式和分析 Spring AOP 实现原理的方式十分相似，如果对上一篇文章理解得好，Spring 的事务实现完全可以按照同样的方式来进行分析。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>实例程序很简单，已经同步到上文 github 链接上了，在 spring-example 模块的 <code>top.aprilyolies.example.tx</code> 包之下，执行前还需要先在数据库中创建数据表，sql 文件在当前模块下的 db 文件夹下。</p>
<blockquote>
<p>主函数 top.aprilyolies.example.tx.TxApp</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxApp</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-tx.xml&quot;</span>);</span><br><span class="line">		<span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">		user.setSex(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">		user.setName(<span class="string">&quot;eva&quot;</span>);</span><br><span class="line">		user.setAge(<span class="number">23</span>);</span><br><span class="line">		userService.save(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pojo 类省略 getter 和 setter 方法 top.aprilyolies.example.tx.User</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>top.aprilyolies.example.tx.UserRowMapper</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRowMapper</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">		user.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">		user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">		user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">		user.setSex(rs.getString(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>top.aprilyolies.example.tx.UserService</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>top.aprilyolies.example.tx.UserServiceImpl</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">JdbcTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.template.setDataSource(dataSource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">		template.update(<span class="string">&quot;insert into user(name,age,sex) values (?,?,?)&quot;</span>, user.getName(), user.getAge(), user.getSex());</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Test tx&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>top.aprilyolies.example.tx.UserService</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>spring-tx.xml</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">	   xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">	   xmlns:tx=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="line">	   xsi:schemaLocation=<span class="string">&quot;</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">	&lt;tx:annotation-driven/&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id=<span class="string">&quot;transactionManager&quot;</span> class=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="line">		&lt;!-- 关联数据源 --&gt;</span><br><span class="line">		&lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 基于Druid数据库链接池的数据源配置 --&gt;</span><br><span class="line">	&lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> init-method=<span class="string">&quot;init&quot;</span> destroy-method=<span class="string">&quot;clone&quot;</span>&gt;</span><br><span class="line">		&lt;!-- 基本属性driverClassName、 url、user、password --&gt;</span><br><span class="line">		&lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql://localhost:3306/common&quot;</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;kuaile1..&quot;</span>/&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;top.aprilyolies.example.tx.UserServiceImpl&quot;</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>执行主函数，会发现程序抛出运行时异常，查看数据库可以看到我们准备插入的数据没有出现。如果我们将 <code>top.aprilyolies.example.tx.UserServiceImpl</code> 类的 @Transactional 注解去掉，再执行主函数，这时可以看到程序同样是抛出了运行时异常，但是当前这条记录却被插入了数据库中。</p>
<p>解释就是当我们使用 @Transactional 注解时，那么 spring 在执行对应的方法时会开启事务，这样如果在事务中 java 程序出现异常，spring 就会自动完成事务的回滚。当把 @Transactional 注解去掉后，我们就是执行的普通方法，这样默认的事务机制是自动提交，当执行完 <code>template.update</code> 方法时，记录已经进入数据库，此时再抛出异常，将不会对结果产生影响。当然这只是直观的感受，具体的实现还是要看源码，本文的主要内容也就是这个。</p>
<h2 id="标签解析"><a href="#标签解析" class="headerlink" title="标签解析"></a>标签解析</h2><p>在我们的 spring 配置文件中只有一个特殊标签 &lt;tx:annotation-driven&#x2F;&gt;，根据上文中的介绍，我们直接定位到 <code>TxNamespaceHandler#init</code> 方法如下，很明显这里应该关注 &lt;tx:annotation-driven&#x2F;&gt; 标签对应的 AnnotationDrivenBeanDefinitionParser。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;advice&quot;</span>, <span class="keyword">new</span> <span class="title class_">TxAdviceBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;annotation-driven&quot;</span>, <span class="keyword">new</span> <span class="title class_">AnnotationDrivenBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;jta-transaction-manager&quot;</span>, <span class="keyword">new</span> <span class="title class_">JtaTransactionManagerBeanDefinitionParser</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AnnotationDrivenBeanDefinitionParser 类实现了 BeanDefinitionParser 接口，直接看接口的 parse 方法实现。第一行代码就是向 spring 容器注册了一个 TransactionalEventListenerFactory 相关的 bean，这个 bean 的作用暂时没有深究。接下来就是一个 if-else 分支，也就是说 spring 的事务实现有两种模式，如果在 &lt;tx:annotation-driven&#x2F;&gt; 标签中指定了 mode 属性为 “aspectj”，那么就会实现 aspectj 模式的事务机制，否则就是通过代理的方式实现事务，当然 spring 默认情况下就是采用的代理方式来实现事务处理，这也就是开篇说 Spring 事务机制跟 Spring AOP 实现原理有关的原因。aspectj 模式这里没做深入的了解，以后如果用上了就再看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">    registerTransactionalEventListenerFactory(parserContext);	<span class="comment">// 根本就是向 spring 容器注册了一个 TransactionalEventListenerFactory 相关的 bean</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mode</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;mode&quot;</span>);	<span class="comment">// 默认是通过 proxy 的方式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;aspectj&quot;</span>.equals(mode)) &#123;	<span class="comment">// 这里说明事务支持的实现有两种方式，aspectj 和 proxy 的方式</span></span><br><span class="line">        <span class="comment">// mode=&quot;aspectj&quot;	// 这种模式没接触过，暂不了解</span></span><br><span class="line">        registerTransactionAspect(element, parserContext);</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;javax.transaction.Transactional&quot;</span>, getClass().getClassLoader())) &#123;</span><br><span class="line">            registerJtaTransactionAspect(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 主要是向 spring 容器注册了四个 BeanDefinition，包括 AnnotationTransactionAttributeSource、TransactionInterceptor、BeanFactoryTransactionAttributeSourceAdvisor</span></span><br><span class="line">        <span class="comment">// mode=&quot;proxy&quot; 以及 CompositeComponentDefinition，都完成了一些属性的设置</span></span><br><span class="line">        AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接看 else 分支，它就是调用了 <code>AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</code> 方法，里边的实现其实就是跟 Spring AOP 的实现一样的套路，代码如下，不过这里注册的 bean 稍多，有五个包括 InfrastructureAdvisorAutoProxyCreator(实现了 SmartInstantiationAwareBeanPostProcessor 接口，负责代理类的生成)、AnnotationTransactionAttributeSource（主要是用来存储一些事务相关的属性信息）、TransactionInterceptor（事务实现的核心拦截器，事务的回滚都是在其中完成）、BeanFactoryTransactionAttributeSourceAdvisor（增强器）<br>以及 CompositeComponentDefinition（上述三种 bean 的组合）。请留意这些 bean，因为在后边的事务实现中，除了最后一个组合 bean，均有涉及到。还有就是要注意这句代码 <code>advisorDef.getPropertyValues().add(&quot;adviceBeanName&quot;, interceptorName);</code>，advisorDef 代表的就是 BeanFactoryTransactionAttributeSourceAdvisor 类对应的 BeanDefinition，而 interceptorName 就是 TransactionInterceptor 实例在 spring 容器中的唯一标识符，当执行完这条代码后，那么 advisor 就算是持有了 TransactionInterceptor 的唯一标识符了，也就能够间接的获取到 spring 容器中的 TransactionInterceptor 实例了。<br><code>interceptorDef.getPropertyValues().add(&quot;transactionAttributeSource&quot;, new RuntimeBeanReference(sourceName));</code> 这句代码的作用同理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">configureAutoProxyCreator</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">    <span class="comment">// 核心就是注册了 InfrastructureAdvisorAutoProxyCreator 对应的 bean，并设置了它创建代理的方式</span></span><br><span class="line">    AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">    <span class="type">String</span> <span class="variable">txAdvisorBeanName</span> <span class="operator">=</span> TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;	<span class="comment">// 和事务相关的增强器唯一标识符</span></span><br><span class="line">    <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">eleSource</span> <span class="operator">=</span> parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the TransactionAttributeSource definition.</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">sourceDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(	<span class="comment">// 这一部分就是创建一个 RootBeanDefinition，持有了 eleSource，角色为 ROLE_INFRASTRUCTURE，并进行了注册</span></span><br><span class="line">                <span class="string">&quot;org.springframework.transaction.annotation.AnnotationTransactionAttributeSource&quot;</span>);</span><br><span class="line">        sourceDef.setSource(eleSource);</span><br><span class="line">        sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceName</span> <span class="operator">=</span> parserContext.getReaderContext().registerWithGeneratedName(sourceDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the TransactionInterceptor definition.	// TransactionInterceptor 实现了 MethodInterceptor 接口，说明它可以被当做方法拦截器使用</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">interceptorDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(TransactionInterceptor.class);	<span class="comment">// 这一部分就是创建了一个 TransactionInterceptor 对应的 RootBeanDefinition</span></span><br><span class="line">        interceptorDef.setSource(eleSource);	<span class="comment">// 持有了 eleSource，角色为 ROLE_INFRASTRUCTURE</span></span><br><span class="line">        interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        registerTransactionManager(element, interceptorDef);	<span class="comment">// 为当前 BeanDefinition 添加了一个 transactionManagerBeanName 属性</span></span><br><span class="line">        interceptorDef.getPropertyValues().add(<span class="string">&quot;transactionAttributeSource&quot;</span>, <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(sourceName));	<span class="comment">// 为当前 BeanDefinition 添加了一个 transactionAttributeSource 属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">interceptorName</span> <span class="operator">=</span> parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);	<span class="comment">// 注册当前的 RootBeanDefinition</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the TransactionAttributeSourceAdvisor definition.	// Advisor 后缀，猜测它能当做增强使用</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">advisorDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(BeanFactoryTransactionAttributeSourceAdvisor.class);	<span class="comment">// 构建 BeanFactoryTransactionAttributeSourceAdvisor 对应的 RootBeanDefinition</span></span><br><span class="line">        advisorDef.setSource(eleSource);</span><br><span class="line">        advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        advisorDef.getPropertyValues().add(<span class="string">&quot;transactionAttributeSource&quot;</span>, <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(sourceName));	<span class="comment">// 指定了 transactionAttributeSource 和 adviceBeanName 属性</span></span><br><span class="line">        advisorDef.getPropertyValues().add(<span class="string">&quot;adviceBeanName&quot;</span>, interceptorName);</span><br><span class="line">        <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;order&quot;</span>)) &#123;</span><br><span class="line">            advisorDef.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, element.getAttribute(<span class="string">&quot;order&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);</span><br><span class="line"></span><br><span class="line">        <span class="type">CompositeComponentDefinition</span> <span class="variable">compositeDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositeComponentDefinition</span>(element.getTagName(), eleSource);</span><br><span class="line">        compositeDef.addNestedComponent(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(sourceDef, sourceName));</span><br><span class="line">        compositeDef.addNestedComponent(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(interceptorDef, interceptorName));</span><br><span class="line">        compositeDef.addNestedComponent(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(advisorDef, txAdvisorBeanName));</span><br><span class="line">        parserContext.registerComponent(compositeDef);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里 &lt;tx:annotation-driven&#x2F;&gt; 标签的解析过程就算完成了，总结下来就是注册了一个 TransactionalEventListenerFactory，然后根据标签属性来确定事务的实现模式是 aspectj 还是 proxy，如果是 proxy 方式，那么就是向 spring 容器中注册了上述的五个 bean。</p>
<h2 id="构建事务代理类"><a href="#构建事务代理类" class="headerlink" title="构建事务代理类"></a>构建事务代理类</h2><p>上文已经提到了在 &lt;tx:annotation-driven&#x2F;&gt; 标签的解析过程中会向 spring 容器注册五个类型的 bean，我这里再罗列一下，因为事务代理类的构建和事务机制的实现都和前四个类型的 bean 息息相关，关于他们的作用我都进行了说明，其中第一个 bean 就是用来构建事务代理类的，它的实现模式跟 spring aop 基本一致。</p>
<ul>
<li><p>InfrastructureAdvisorAutoProxyCreator(实现了 SmartInstantiationAwareBeanPostProcessor 接口，负责代理类的生成)</p>
</li>
<li><p>AnnotationTransactionAttributeSource（主要是用来存储一些事务相关的属性信息）</p>
</li>
<li><p>TransactionInterceptor（事务实现的核心拦截器，事务的回滚都是在其中完成）</p>
</li>
<li><p>BeanFactoryTransactionAttributeSourceAdvisor（增强器）</p>
</li>
<li><p>CompositeComponentDefinition（上述三种 bean 的组合）</p>
</li>
</ul>
<p>InfrastructureAdvisorAutoProxyCreator 实现了 SmartInstantiationAwareBeanPostProcessor 接口，按照上一篇文章所说的，我们直接关注到事务代理类创建的方法如下：</p>
<blockquote>
<p>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>	<span class="comment">// 尝试从缓存中获取代理 bean，没有的话进行构建，核心就是构建 enhancer，根据 enhancer 构建代理类 class，然后通过 class 构建代理类实例，最后将 callbacks 设置到其中</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);	<span class="comment">// 核心就是构建 enhancer，根据 enhancer 构建代理类 class，然后通过 class 构建代理类实例，最后将 callbacks 设置到其中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码在上一篇文章中已经说过了，所以不再赘述，但是在 wrapIfNecessary 方法的实现中，和 spring aop 原理分析中的样例代码不一样，这里通过 <code>getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</code> 获取到的 specificInterceptors 只有一个如下图所示，这个跟 spring aop 原理分析文章中得到的和 @Before、@After、@Around 三个注解代表的 Advisor 相对应。好了自己看看现在获取到的这个 Advisor 的类型，是不是很熟悉呢？？没错这个 advisor 就是上文中提出的那个五个 bean 当中的一个。</p>
<div style="text-align:center;"><img src="https://image.aprilyolies.top/static/images/common/0c36424c3dd178707b5f7641852de18c.jpg" width=600 /></div>

<center>本例中唯一的 Advisor</center>

<p>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要代理，如果是，获取满足 beanClass 的 advisor，然后构建代理类：验证代理工厂长持有的目标类，然后构建 enhancer，根据 enhancer 构建代理类 class，然后通过 class 构建代理类实例，最后将 callbacks 设置到其中</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;	<span class="comment">// 无需代理，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;	<span class="comment">// 基础类和应跳过的类直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.	// 获取满足 beanClass 的 advisor，进行过排序</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);	<span class="comment">// 所以这个集合存放的是对应的 bean 是否增强的信息</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(	<span class="comment">// 验证代理工厂长持有的目标类，然后构建 enhancer，根据 enhancer 构建代理类 class，然后通过 class 构建代理类实例，最后将 callbacks 设置到其中</span></span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">        <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所以这个集合存放的是对应的 bean 是否增强的信息</span></span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到这个 advisor 后就是构建代理类，上篇文章中走的是 cglib 代理分支，而现在走的是 jdk 代理方式的分支，判断的逻辑是由下边代码的 <code>evaluateProxyInterfaces(beanClass, proxyFactory);</code> 这一行所决定的，该行代码会看目标 class 是否有可以代理的接口，有的话将接口 class 添加到 proxyFactory 中，否则设置代理方式为代理目标类即 cglib 的方式。因为我们的目标类是 UserServiceImpl，它实现了 UserService 接口，因此是满足 jdk 动态代理条件的。另外需要注意的是下边的方法通过参数传入的 specificInterceptors 被转换为了 Advisor，它又被传入了 proxyFactory 中，所以 proxyFactory 是持有了我们 Advisor 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> &#123;	<span class="comment">// TargetSource 封装了我们的目标实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.copyFrom(<span class="built_in">this</span>);	<span class="comment">// 当前类的属性复制到 ProxyFactory 中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;	<span class="comment">// 这里就是判断代理目标类还是接口分别对应 cglib 和 jdk 代理方式</span></span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;	<span class="comment">// 看是否属性值指定了 org.springframework.aop.framework.autoproxy.AutoProxyUtils.preserveTargetClass，这种情况采用目标类代理方式 cglib</span></span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="literal">true</span>);	<span class="comment">// 这里设置代理方式为 cglib</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;	<span class="comment">// 看目标 class 是否有可以代理的接口，有的话将接口 class 添加到 proxyFactory 中，否则设置代理方式为代理目标类</span></span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取公有的 interceptors，然后和 specificInterceptors 一起构建为 advisors 返回</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);	<span class="comment">// 这个参数持有了代理目标</span></span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="built_in">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;	<span class="comment">// advisors 预过滤</span></span><br><span class="line">        proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证代理工厂长持有的目标类，然后构建 enhancer，根据 enhancer 构建代理类 class，然后通过 class 构建代理类实例，最后将 callbacks 设置到其中</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道要采用 jdk 动态代理的方式后，我们就细看这个代理类是如何构建的，对应的 InvocationHandler 又是怎样的，之所以关注 InvocationHandler，是因为 jdk 代理类的根本逻辑还是调用 InvocationHandler 实例的 invoke 方法。我们直接看上边代码块的最后一句即 <code>return proxyFactory.getProxy(getProxyClassLoader());</code> 。它的实现如下 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建代理类</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);	<span class="comment">// jdk：获取必须的接口信息，构建代理类，invocation handler 就是 JdkDynamicAopProxy 实例</span></span><br><span class="line">&#125;	<span class="comment">// cglib：验证代理工厂长持有的目标类，然后构建 enhancer，根据 enhancer 构建代理类 class，然后通过 class 构建代理类实例，最后将 callbacks 设置到其中</span></span><br></pre></td></tr></table></figure>

<p>逻辑跟 aop 实现的分析是一样的，第一段代码执行的结果可以算作是一个工厂类，通过下边的代码我们知道拿到的是一个 JdkDynamicAopProxy 实例，然后我们调用它的 getProxy 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();	<span class="comment">// 执行到这里，说明采用 cglib 代理方式</span></span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">        &#125;	<span class="comment">// 目标类是接口或者是 Proxy 接口实现类，那么进行 jdk 代理</span></span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);	<span class="comment">// 这里就是进行 jdk 代理方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下边就是 <code>JdkDynamicAopProxy#getProxy(java.lang.ClassLoader)</code> 方法的实现，熟悉 jdk 动态代理的小伙伴应该立即就能知道这是一个典型的通过 Proxy 类创建 jdk 代理类的过程。其中 proxiedInterfaces 参数代表着创建的代理类需要实现的接口类型。而紧跟的那个参数 this 其实就是 InvocationHandler 实例了。如果我们执行代理类的方法，那么该实例的 invoke 方法将会被调用，这是本文下一部分将要分析的内容。</p>
<p>记住这里的 this 代表着 JdkDynamicAopProxy 类，可以肯定它实现了 InvocationHandler 接口，而且它持有了 ProxyFactory 实例，上文我们指出过 ProxyFactory 又持有了本例中唯一的 Advisor，所以可以说我们的 InvocationHandler 也是间接的持有了这个唯一的 Advisor。</p>
<p>proxiedInterfaces 是一个数组类型，这就说明我们的代理类可以实现多个接口，就拿本例来说，我把所有的接口类型贴在下边，可以看到我们最关心的 UserService 接口就在其中，至于其它的几个接口怎么来的请自行查看 <code>AopProxyUtils.completeProxiedInterfaces(this.advised, true);</code> 方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>	<span class="comment">// 获取必须的接口信息，构建代理类，invocation handler 就是 JdkDynamicAopProxy 实例</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating JDK dynamic proxy: &quot;</span> + <span class="built_in">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;	<span class="comment">// 获取全部的代理接口集合，包括 advised 中获取的全部接口集合以及制定的三个接口</span></span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised, <span class="literal">true</span>);</span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);	<span class="comment">// 看接口中是否定义了 equals 和 hashcode 方法</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="built_in">this</span>);	<span class="comment">// 构建代理类，invocation handler 就是当前实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="text-align:center;"><img src="https://image.aprilyolies.top/static/images/common/78484ac56ecacdb392d82c6c39fe7e8e.jpg" width=600 /></div>

<center>本例事务代理类实现的接口</center>

<p>

<p>对代理类的创建过程进行一下总结，我们首先是从环境中获取到了本例中唯一的一个 advisor，将其注入到了 ProxyFactory 中，然后就是通过 ProxyFactory 来构建 JdkDynamicAopProxy 实例，它可以看做是一个工厂类，最后就是通过它来构建我们的代理类，代理类实现了上图中的四个接口，我们本例关心的 UserService 接口就在其中，传入的 InvocationHandler 就是 JdkDynamicAopProxy 实例，下一部分的内容就是看该实例的 invoke 方法实现。</p>
<h2 id="事务执行过程"><a href="#事务执行过程" class="headerlink" title="事务执行过程"></a>事务执行过程</h2><p>上文已经指出了代理类在执行目标方法时，会直接调用 InvocationHandler 的 invoke 方法，那么这一部分，我们将分析 invoke 方法的实现是怎样的。我已经将 invoke 方法的实现代码贴出来了，内容比较长，但我们真正需要关心的就是后半部分，前边的代码只是针对特殊方法调用的处理，我暂时没有去深入了解，同样的不影响我们对于 spring 事务机制实现原理的理解。跟 cglib 代理方式一样，本段代码中 <code>if (this.advised.exposeProxy)</code> 这个代码块也对代理类的暴露进行了处理，这样我们就能在我们的用户代码中拿到当前代理类，详细的使用方式参考上一篇文章的示例代码二。</p>
<blockquote>
<p>org.springframework.aop.framework.JdkDynamicAopProxy#invoke</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">oldProxy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">setProxyContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.targetSource;	<span class="comment">// 这里是目标类</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;	<span class="comment">// 对于 equals 方法的处理</span></span><br><span class="line">            <span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">            <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;	<span class="comment">// 对于 hashcode 方法的处理</span></span><br><span class="line">            <span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">            <span class="keyword">return</span> hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;	<span class="comment">// 对于 DecoratingProxy 接口方法的处理</span></span><br><span class="line">            <span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line">            <span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="built_in">this</span>.advised);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;	<span class="comment">// 对于 Advised 接口实现类方法的处理</span></span><br><span class="line">                method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">            <span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">            <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="built_in">this</span>.advised, method, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.advised.exposeProxy) &#123;	<span class="comment">// 看是否需要暴露代理类</span></span><br><span class="line">            <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target,</span></span><br><span class="line">        <span class="comment">// in case it comes from a pool.</span></span><br><span class="line">        target = targetSource.getTarget();	<span class="comment">// 获取目标实例</span></span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="literal">null</span> ? target.getClass() : <span class="literal">null</span>);	<span class="comment">// 获取目标实例类</span></span><br><span class="line">        <span class="comment">// 尝试从缓存中获取 interceptorList，没有的话就从当前实例中获取（获取 Advised 的全部 advisors，看 advisor 是否适配当前方法，适配的话从 advisor 中获取到 Advice，然后将其添加到 interceptorList 集合返回）</span></span><br><span class="line">        <span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span></span><br><span class="line">        <span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">            <span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">            <span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">            <span class="type">MethodInvocation</span> <span class="variable">invocation</span> <span class="operator">=</span>	<span class="comment">// 构建 ReflectiveMethodInvocation 来控制 interceptor 链的调用</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            <span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Massage return value if necessary.</span></span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">                returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="comment">// Special case: it returned &quot;this&quot; and the return type of the method</span></span><br><span class="line">            <span class="comment">// is type-compatible. Note that we can&#x27;t help if the target sets</span></span><br><span class="line">            <span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">            retVal = proxy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="literal">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopInvocationException</span>(</span><br><span class="line">                    <span class="string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            <span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// Restore old proxy.</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下边代码的后半部分就是我们应该关注的点了，首先是拦截器链的获取，通过 <code>this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</code> 这段代码进行，上文我们已经指出了 InvocationHandler 持有了 ProxyFactory，而这句代码的 advised 实例其实就是 ProxyFactory，它持有了我们开篇中指出的五个 bean 中的 BeanFactoryTransactionAttributeSourceAdvisor（增强器）对吗？好了那么这里的拦截器链就是通过它来获取的，过程比较繁琐，我也不想细究它每一行代码是怎样的，只需要了解上文中指出的，在进行标签的解析时，BeanFactoryTransactionAttributeSourceAdvisor 对应的 BeanDefinition 是持有了 TransactionInterceptor 实例的唯一标识符的，就凭这一点，再通过 BeanFactoryTransactionAttributeSourceAdvisor 拿到 TransactionInterceptor 就不是什么难以理解的事了，所以这里只给出最终的获取结果就好。特别注意哦这个唯一的拦截器是不是也很熟悉啊？？没错，正好就是本文开篇指出的那个五个 bean 中的 TransactionInterceptor（事务实现的核心拦截器，事务的回滚都是在其中完成）对吗？这是一个很关键的拦截器，事务的实现就是靠它。</p>
<div style="text-align:center;"><img src="https://image.aprilyolies.top/static/images/common/b2be9904065f81a1b47dca8b0f998b0e.jpg" width=600 /></div>

<center>拦截器链内容</center>

<p>

<p>再回到我们的分析点，就是 <code>JdkDynamicAopProxy#invoke</code> 方法中获取拦截器链的那句，我们已经拿到了必要的拦截器链，里边就只有一个拦截器 TransactionInterceptor。接着就是一个 if-else 分支，我们这里的拦截器链是有内容的，所以走 else 分支如下，里边的逻辑又跟 cglib 的拦截器链调用过程一样了，新构建出来的 ReflectiveMethodInvocation 类持有了代理相关的大部分信息，它还负责着拦截器链的调用流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We need to create a method invocation...</span></span><br><span class="line"><span class="type">MethodInvocation</span> <span class="variable">invocation</span> <span class="operator">=</span>	<span class="comment">// 构建 ReflectiveMethodInvocation 来控制 interceptor 链的调用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">retVal = invocation.proceed();</span><br></pre></td></tr></table></figure>

<p>想都不用想，<code>invocation.proceed();</code> 方法将会触发拦截器链第一个节点的逻辑，也就是 TransactionInterceptor 方法，尽管已经猜到了，我还是要贴出 <code>invocation.proceed();</code> 代码实现如下，因为是第一次调用，所以这里的 currentInterceptorIndex 值为 -1，interceptorsAndDynamicMethodMatchers 其实就是我们的拦截器链，它是在构造函数中被初始化的，里边就只有一个元素为 TransactionInterceptor 实例，根据以上条件，程序将会执行最后一行代码 <code>return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</code>，即 TransactionInterceptor 实例的 invoke 方法了，我们跟进去看实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.currentInterceptorIndex == <span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();	<span class="comment">// 这里就是触发连接点方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">interceptorOrInterceptionAdvice</span> <span class="operator">=</span>	<span class="comment">// 逐个获取 interceptorOrInterceptionAdvice</span></span><br><span class="line">            <span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="built_in">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">        <span class="comment">// been evaluated and found to match.</span></span><br><span class="line">        <span class="type">InterceptorAndDynamicMethodMatcher</span> <span class="variable">dm</span> <span class="operator">=</span></span><br><span class="line">                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        Class&lt;?&gt; targetClass = (<span class="built_in">this</span>.targetClass != <span class="literal">null</span> ? <span class="built_in">this</span>.targetClass : <span class="built_in">this</span>.method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="built_in">this</span>.method, targetClass, <span class="built_in">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">            <span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">        <span class="comment">// been evaluated statically before this object was constructed.	// 对逐个获取的 interceptorOrInterceptionAdvice 进行 invoke 调用</span></span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="built_in">this</span>);	<span class="comment">// 参数为通过代理各项参数构建的 CglibMethodInvocation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现如下，常规操作，只有这里采用了一个特殊的传参方式，传入的是一个方法引用，了解就好，继续往下跟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">    <span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">    <span class="comment">// as well as the method, which may be from an interface.	获取目标类的类型</span></span><br><span class="line">    Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于到了我们期待已久的事务实现逻辑代码了，赶紧的贴出源码开心一下，代码主干分为两个分支，就本例而言，我们只使用到了 if 分支，所以就只截取这一部分展示。而没用到的那一部分，我就没有做深入了解了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span>	<span class="comment">// 触发真正的业务逻辑，如果发生异常就进行回滚，否则进行事务的提交</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.reactiveAdapterRegistry != <span class="literal">null</span>) &#123;	<span class="comment">// 暂不做了解</span></span><br><span class="line">        <span class="type">ReactiveAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="built_in">this</span>.reactiveAdapterRegistry.getAdapter(method.getReturnType());</span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReactiveTransactionSupport</span>(adapter).invokeWithinTransaction(method, targetClass, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">    <span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">PlatformTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);	<span class="comment">// 获取事务管理器，尝试从缓存中获取 PlatformTransactionManager，没有的话就从 BeanFactory 中获取，缓存后进行返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);	<span class="comment">// 获取方法的全限定名，没有的话通过 TransactionAttribute 的描述符代替</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.	// 将 TransactionAttribute 封装为 DelegatingTransactionAttribute，从 PlatformTransactionManager 中获取 TransactionStatus</span></span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(tm, txAttr, joinpointIdentification);	<span class="comment">// 最后构建 TransactionInfo（通过参数构建 TransactionInfo，设置了状态信息， 将事务信心保存到线程本地变量中，同时保留了原先的事务信息，返回）</span></span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">            <span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();	<span class="comment">// 继续下一个 advice 的调用，如果没有后续的 advice，直接进行目标方法的的调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// target invocation exception</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);	<span class="comment">// 对于异常发生后，事物的处理方式，提交或者回滚</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;	<span class="comment">// 恢复线程本地变量中的 TransactionInfo</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">            <span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">            <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> txInfo.getTransactionStatus();</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="literal">null</span> &amp;&amp; txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">                retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常情况下，进行事务的提交</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看 <code>TransactionAttributeSource tas = getTransactionAttributeSource();</code> 这句，它做的事情就是获取它持有的 TransactionAttributeSource 实例，不知道它具体是什么吗？？直接给出结果就知道了，又是一个熟悉的类，没错就是本文开篇中那五个 bean 中的 AnnotationTransactionAttributeSource（主要是用来存储一些事务相关的属性信息）。它有一个属性 attributeCache，是一个 ConcurrentHashMap 实例，本例中里边有 528 项记录。不要慌，其实这些记录中只有两项的值不为空。其他的都是空值，我们所要关注的也就只有这不为空的两项，他们的 key 就是本例中位于 UserService 接口和 UserServiceImpl 实现类中两个 save 方法对应的 MethodClassKey 实例，而对应的值呢，就是对这两个方法进行调用时事务相关的一些属性值，也就是说在这 528 项中，只有值不为空的两项他们对应的方法被调用时会触发事务机制，否则是不会触发事务机制的。如果觉得比较绕，那就还是请继续看后边的分析吧。</p>
<div style="text-align:center;"><img src="https://image.aprilyolies.top/static/images/common/46aada5933fc013fafa4087f30b6a5db.jpg" width=600 /></div>

<center>TransactionAttributeSource 实例内容</center>

<p>

<p>接着就是从 TransactionAttributeSource 中获取事务相关的属性 TransactionAttribute，我们这里调用的是 UserServiceImpl 类的 save 方法，上边已经指出了在 attributeCache 缓存中，该方法对应的值不为空，这样我们获取的 TransactionAttribute 就不是空，再调用 <code>determineTransactionManager(txAttr);</code> 这个方法获取事务管理器，其实就本例而言，获取的过程跟参数没啥关系，因为参数 txAttr 中的 qualifier 属性为空串，所以获取事务管理器时就是依据 <code>TransactionAspectSupport#transactionManagerBeanName</code> 字段来获取的，具体的代码就不贴了，就本例而言，根本拿到的就是我们在 spring 配置文件中指定的那个 “transactionManager”，它持有了配置文件中指定的 dataSource 如下图，了解这个就完事。</p>
<div style="text-align:center;"><img src="https://image.aprilyolies.top/static/images/common/d96e301db24ca4df82ad35126e852806.jpg" width=600 /></div>

<center>transactionManager 实例内容</center>

<p>


<p>再往下就是 <code>final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</code> 这行代码，从方法名就知道这是一个方法的唯一标识符，怎么来的不用深究，直接给出结果。</p>
<div style="text-align:center;"><img src="https://image.aprilyolies.top/static/images/common/6860bb9123349188e587b933d57d6b24.jpg" width=600 /></div>

<center>方法的唯一标识符</center>

<p>

<p>再往下就是构建 TransactionInfo 实例，和事务操作相关的信息都封装在其中，代码如下，也没有什么要注意的地方，注释中已经对代码进行了解释，反正最终返回的就是构建出来的 TransactionInfo，它持有了 TransactionManager、TransactionAttribute、方法的唯一标识符信息，知道这些就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 TransactionAttribute 封装为 DelegatingTransactionAttribute，从 PlatformTransactionManager 中获取 TransactionStatus</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span>	<span class="comment">// 最后构建 TransactionInfo（通过参数构建 TransactionInfo，设置了状态信息， 将事务信心保存到线程本地变量中，同时保留了原先的事务信息，返回）</span></span><br><span class="line"><span class="keyword">protected</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; txAttr.getName() == <span class="literal">null</span>) &#123;	<span class="comment">// 将 TransactionAttribute 封装为 DelegatingTransactionAttribute</span></span><br><span class="line">        txAttr = <span class="keyword">new</span> <span class="title class_">DelegatingTransactionAttribute</span>(txAttr) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="literal">null</span>) &#123;</span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Skipping transactional joinpoint [&quot;</span> + joinpointIdentification +</span><br><span class="line">                        <span class="string">&quot;] because no transaction manager has been configured&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	<span class="comment">// 通过参数构建 TransactionInfo，设置了状态信息， 将事务信心保存到线程本地变量中，同时保留了原先的事务信息，返回</span></span><br><span class="line">    <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往下走就是执行 <code>retVal = invocation.proceedWithInvocation();</code> ，这里的 invocation 就是用来控制拦截器链执行的实例的 proceed 方法，是通过函数引用的方式传进来的，这一点上文已经说过了，我们已经执行过一次它的 proceed 方法了，被调用的是 TransactionInterceptor 拦截器，因为一共就只有只有一个拦截器，所以本次 <code>ReflectiveMethodInvocation#proceed</code> 方法的调用就会满足 <code>if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1)</code> 判断条件，根据上一篇文章的分析，我们知道这将会导致用户代码的调用，也就是业务逻辑中进行数据库的插入操作。因为这个业务逻辑中，我们人为的抛出了一个运行时异常，所以这个异常就会被上层代码所捕获，而捕获点就是 <code>TransactionAspectSupport#invokeWithinTransaction</code> 方法的 <code>catch (Throwable ex)</code> 处，事务的回滚操作也就是在这里完成的。</p>
<p>在该 catch 代码块中核心就是调用了 completeTransactionAfterThrowing 方法，从方法名就知道其中的核心实现就是完成异常捕获后的事务处理，完整的方法实现如下，根据 if-else 的分支结构，我们就能知道就算是异常出现，那么对于事务的处理也是有两种模式的，if 代码块中的 rollback 方法名我们就能知道这里进行的是回滚操作，而 else 代码块中的 commit 方法名，我们知道是提交操作，也就是说不进行回滚。那么 if 判断成立的条件是什么呢？？第一条很明显，就是事务信息 TransactionInfo 持有的事务属性 transactionAttribute 不能为空，其次就是事务属性 transactionAttribute 的 rollbackOn 方法的返回结果了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于异常发生后，事物的处理方式，提交或者回滚</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">completeTransactionAfterThrowing</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() +</span><br><span class="line">                    <span class="string">&quot;] after exception: &quot;</span> + ex);</span><br><span class="line">        &#125;	<span class="comment">// 第二个条件主要是判断回滚规则，最基本的就是在发生运行时异常和错误时发生回滚</span></span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute != <span class="literal">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());	<span class="comment">// 事务回滚</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);</span><br><span class="line">                ex2.initApplicationException(ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We don&#x27;t roll back on this exception.</span></span><br><span class="line">            <span class="comment">// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;	<span class="comment">// 如果捕获到的异常不满足回滚规则，直接进行提交</span></span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, ex);</span><br><span class="line">                ex2.initApplicationException(ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看 rollbackOn 方法的根本实现如下，上半部分的 rollbackRules 的处理部分我没有看懂它的意思，因为就本例而言，上边的判断条件确实没用上，所以不太好理解它的意思。紧接着下边又有一个判断条件，即 <code>return super.rollbackOn(ex);</code> 这句代码，它是在父类中实现的，我们点进去就能知道，它会对捕获到的异常进行判断，如果是运行时异常或者是 Error 错误，那么就会返回 true，否则返回 false。</p>
<blockquote>
<p>org.springframework.transaction.interceptor.RuleBasedTransactionAttribute#rollbackOn</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>	<span class="comment">// 这里主要是判断回滚规则，最基本的就是在发生运行时异常和错误时发生回滚</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rollbackOn</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Applying rules to determine whether transaction should rollback on &quot;</span> + ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">RollbackRuleAttribute</span> <span class="variable">winner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">deepest</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.rollbackRules != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (RollbackRuleAttribute rule : <span class="built_in">this</span>.rollbackRules) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> rule.getDepth(ex);</span><br><span class="line">            <span class="keyword">if</span> (depth &gt;= <span class="number">0</span> &amp;&amp; depth &lt; deepest) &#123;</span><br><span class="line">                deepest = depth;</span><br><span class="line">                winner = rule;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Winning rollback rule is: &quot;</span> + winner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// User superclass behavior (rollback on unchecked) if no rule matches.</span></span><br><span class="line">    <span class="keyword">if</span> (winner == <span class="literal">null</span>) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;No relevant rollback rule found: applying default rules&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.rollbackOn(ex);	<span class="comment">// 这里说明只有在发生运行时异常和错误时才会触发回滚</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !(winner <span class="keyword">instanceof</span> NoRollbackRuleAttribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回到我们 if 分支那里，因为我们在业务代码中抛出的异常是运行时异常，所以 if 判断的第二个条件也是成立的，也就是说我们将要进行事务的回滚操作。但是如果我们将业务代码中的异常修改为非运行异常，那么此时事务就会正常提交。这样带来的结果就是数据入库了。还是看看事务回滚的代码实现吧，根本的就是调用的下边的代码，更加细节的部分我已经没有去深究了，因为到这里对于理解事务机制的实现已经足够了，我这里就仅仅是将代码段的作用给进行标注。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试调用事务同步器的前置处理方法,进行事务的回滚操作,逐个触发同步器链每个元素的 afterCompletion 方法，最后事务回滚后的扫尾工作，设置事务的状态， 线程本地变量中移除资源信息（连接信息），设置连接的自动提交，恢复隔离级别，释放连接，恢复 connection holder 的状态信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="type">boolean</span> unexpected)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">unexpectedRollback</span> <span class="operator">=</span> unexpected;	<span class="comment">// 预期外的回滚</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;	<span class="comment">// 尝试调用事务同步器的前置处理方法</span></span><br><span class="line">            triggerBeforeCompletion(status);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status.hasSavepoint()) &#123;	<span class="comment">// 看事务状态是否有保存点</span></span><br><span class="line">                <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Rolling back transaction to savepoint&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                status.rollbackToHeldSavepoint();	<span class="comment">// 回滚到保存点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;	<span class="comment">// 是否是新事务呢？</span></span><br><span class="line">                <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Initiating transaction rollback&quot;</span>);</span><br><span class="line">                &#125;	<span class="comment">// 直接进行回滚</span></span><br><span class="line">                doRollback(status);	<span class="comment">// 进行事务的回滚操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;	<span class="comment">// 不是新事务的处理方式，存在现有的事务处理方式</span></span><br><span class="line">                <span class="comment">// Participating in larger transaction</span></span><br><span class="line">                <span class="keyword">if</span> (status.hasTransaction()) &#123;	<span class="comment">// 检查回滚条件</span></span><br><span class="line">                    <span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;	<span class="comment">// 如果局部的事务失败，是否设置全局的事务回滚状态</span></span><br><span class="line">                        <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                            logger.debug(<span class="string">&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        doSetRollbackOnly(status);	<span class="comment">// 仅仅是设置回滚的标志</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                            logger.debug(<span class="string">&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Should roll back transaction but cannot - no transaction available&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Unexpected rollback only matters here if we&#x27;re asked to fail early</span></span><br><span class="line">                <span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">                    unexpectedRollback = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;	<span class="comment">// 触发</span></span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逐个触发同步器链每个元素的 afterCompletion 方法</span></span><br><span class="line">        triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Raise UnexpectedRollbackException if we had a global rollback-only marker</span></span><br><span class="line">        <span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedRollbackException</span>(</span><br><span class="line">                    <span class="string">&quot;Transaction rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;	<span class="comment">// 事务回滚后的扫尾工作，设置事务的状态， 线程本地变量中移除资源信息（连接信息），设置连接的自动提交，恢复隔离级别，释放连接，恢复 connection holder 的状态信息</span></span><br><span class="line">        cleanupAfterCompletion(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要注意一点，就是真正的事务回滚是在上边代码中的 <code>doRollback(status);</code> 语句中完成的，而其他部分就只是一些事务回滚生命周期方法的处理，或者是对于事务回滚后的一些善后工作。关于 <code>doRollback(status);</code> 的实现，我们不妨看看，其实就是跟我们自己进行事务回滚的操作一样，根本还是调用的 <code>java.sql.Connection#rollback()</code> 看到这里我想小伙伴已经对 spring 的事务实现有比较清晰的理解了，至于一些其他的细节部分，如果有精力就可以去看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>	<span class="comment">// 进行事务的回滚操作</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRollback</span><span class="params">(DefaultTransactionStatus status)</span> &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) status.getTransaction();	<span class="comment">// 数据源事务对象</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> txObject.getConnectionHolder().getConnection();	<span class="comment">// 也就是说和数据库交互相关的信息都保存在 DataSourceTransactionObject 实例中</span></span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Rolling back JDBC transaction on Connection [&quot;</span> + con + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        con.rollback();	<span class="comment">// 调用真正的回滚操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionSystemException</span>(<span class="string">&quot;Could not roll back JDBC transaction&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后对 spring 事务代理类的执行过程进行一下总结，我们会从环境中获取到 Advisors 信息，然后根据它来得到拦截器链，而拦截器链的执行是由 ReflectiveMethodInvocation 实例控制的，就我们本例而言，这里拦截器链只有一个元素，就是 TransactionInterceptor 实例，我们将要调用它的 invoke 方法，该方法中会继续下一个拦截器的执行，当所有拦截器执行完后，就会触发用户代码，如果此时用户代码中抛出了运行时异常，只要该异常到达 TransactionInterceptor 被捕获，那么该拦截器就会根据必要的条件来进行事务的回滚或者提交操作。</p>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Spring/">#Spring</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2019/07/25/2019-07-25-SpringMVC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">SpringMVC基本原理分析</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2019/07/21/2019-07-21-Spring-AOP-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Spring AOP 实现原理分析</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">小橘子🍊</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-text">示例程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE%E8%A7%A3%E6%9E%90"><span class="nav-text">标签解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%90%86%E7%B1%BB"><span class="nav-text">构建事务代理类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">事务执行过程</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
