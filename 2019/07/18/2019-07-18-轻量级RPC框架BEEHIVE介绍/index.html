<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Java 后端">
    <meta name="description" content="小橘子🍊的个人主页，欢迎访问~~">
    <meta name="author" content="小橘子🍊">
    
    <title>
        
            轻量级RPC框架BEEHIVE介绍 |
        
        AprilYoLies
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://img.aprilyolies.top/img/typora/avatar.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"aprilyolies.top","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"https://img.aprilyolies.top/img/typora/avatar.jpg","favicon":"https://img.aprilyolies.top/img/typora/avatar.jpg","article_img_align":"center","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"干燥的空气，尘埃的味道，我在其中…踏上旅途！"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://img.aprilyolies.top/img/typora/avatar.jpg">
                </a>
            
            <a class="logo-title" href="/">
                AprilYoLies
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">轻量级RPC框架BEEHIVE介绍</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="https://img.aprilyolies.top/img/typora/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">小橘子🍊</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2019-07-18 09:19:47</span>
        <span class="mobile">2019-07-18 09:19</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/">后台开发</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/RPC/">RPC</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a class="link"   target="_blank" rel="noopener" href="https://github.com/AprilYoLies/beehive" >项目地址<i class="fas fa-external-link-alt"></i></a></p>
<p>beehive 是一款轻量级的 RPC 框架，通过 spring 容器来管理 bean，做到了对用户代码的零入侵，同时通过 spi 拓展机制，实现了自己的 ioc 容器，使得 beehive 能够很方便的对组件进行拓展。</p>
<h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><ul>
<li><p>实现了 SPI 拓展机制，能够方便的进行组件的自定义和替换</p>
</li>
<li><p>提供了两种代理方式的支持（JDK 原生、Javassist）</p>
</li>
<li><p>底层通信采用 Netty 框架，保证稳定性和高效性</p>
</li>
<li><p>对 Zookeeper 注册中心的支持，能够自动的侦测服务的状态，同步进行更新</p>
</li>
<li><p>完成了对与 fastjson 和 hessian 两种序列化器的支持</p>
</li>
<li><p>整合 spring 容器，对用户代码零入侵，使用方便</p>
</li>
<li><p>在客户端实现了两种负载均衡策略的支持（随机选取，轮询选取）</p>
</li>
</ul>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>beehive 加入了对于 spring 容器的支持，使得它在使用过程中可以做到对用户代码的零入侵，使用方式和 dubbo 很类似，在服务端，只需要定义要发布的服务的接口类型，服务的实现类，以及注册中心的地址即可完成启动，其他的一些相关参数可以作为备选项，这里给出一个使用样例。</p>
<blockquote>
<p>provider.xml</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:beehive=<span class="string">&quot;https://www.aprilyolies.top/schema/beehive&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        https://www.aprilyolies.top/schema/beehive https://www.aprilyolies.top/schema/beehive.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;demoServiceImpl&quot;</span> class=<span class="string">&quot;top.aprilyolies.service.BeehiveServiceImpl&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userServiceImpl&quot;</span> class=<span class="string">&quot;top.aprilyolies.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beehive:service id=<span class="string">&quot;demoService&quot;</span> service=<span class="string">&quot;top.aprilyolies.service.BeehiveService&quot;</span></span><br><span class="line">                     ref=<span class="string">&quot;demoServiceImpl&quot;</span> proxy-factory=<span class="string">&quot;jdk&quot;</span> serializer=<span class="string">&quot;hessian&quot;</span> server-port=<span class="string">&quot;7442&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beehive:service id=<span class="string">&quot;userService&quot;</span> service=<span class="string">&quot;top.aprilyolies.service.UserService&quot;</span></span><br><span class="line">                     ref=<span class="string">&quot;userServiceImpl&quot;</span> proxy-factory=<span class="string">&quot;javassist&quot;</span> serializer=<span class="string">&quot;hessian&quot;</span> server-port=<span class="string">&quot;7442&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beehive:registry id=<span class="string">&quot;registry&quot;</span> address=<span class="string">&quot;zookeeper://119.23.247.86:2181&quot;</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>这是服务端的 spring 配置文件，其中 id&#x3D;”demoServiceImpl” 和 id&#x3D;”userServiceImpl” 的 bean 就是服务的实现类，而 &lt;beehive:service&#x2F;&gt; 标签中的 service&#x3D;”top.aprilyolies.service.BeehiveService” 就是待发布服务的接口类型，另外一个 &lt;beehive:service&#x2F;&gt; 类似，最后 &lt;beehive:registry&#x2F;&gt; 标签中定义的就是注册中心地址，目前仅支持 zookeeer。</p>
<p>说完了配置文件，再看看启动程序，很简单，就是一个典型的 spring 容器启动程序如下，不做过多说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;provider.xml&quot;</span>);</span><br><span class="line">    context.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;Provider started on thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;..&quot;</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务端程序后就是客户端程序了，要做的配置也非常简单，仅仅是通过 beehive 引入服务即可，具体的 rpc 过程对于用户来说是绝对透明的，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:beehive=<span class="string">&quot;https://www.aprilyolies.top/schema/beehive&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        https://www.aprilyolies.top/schema/beehive https://www.aprilyolies.top/schema/beehive.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beehive:registry id=<span class="string">&quot;registry&quot;</span> address=<span class="string">&quot;zookeeper://119.23.247.86:2181&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beehive:reference id=<span class="string">&quot;demoService&quot;</span> service=<span class="string">&quot;top.aprilyolies.service.BeehiveService&quot;</span> load-balance=<span class="string">&quot;poll&quot;</span></span><br><span class="line">                       serializer=<span class="string">&quot;hessian&quot;</span> read-timeout=<span class="string">&quot;1000&quot;</span> retry-times=<span class="string">&quot;2&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beehive:reference id=<span class="string">&quot;userService&quot;</span> service=<span class="string">&quot;top.aprilyolies.service.UserService&quot;</span> load-balance=<span class="string">&quot;poll&quot;</span></span><br><span class="line">                       serializer=<span class="string">&quot;hessian&quot;</span> read-timeout=<span class="string">&quot;1000&quot;</span> retry-times=<span class="string">&quot;2&quot;</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>基本跟服务端的配置相似，注册中心的配置是一样的，只有引用服务的标签变成为 &lt;beehive:reference&#x2F;&gt;，该标签的属性设置也跟服务端的服务发布标签有所不同，关于详细的属性说明请看下文。</p>
<p>客户端启动程序服务端一样简单，直接启动程序，查看输出结果即可，不做过多说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;consumer.xml&quot;</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        <span class="type">BeehiveService</span> <span class="variable">demoService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;demoService&quot;</span>, BeehiveService.class);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> demoService.say(<span class="string">&quot;world - &quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;result: &quot;</span> + hello);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数设置说明"><a href="#参数设置说明" class="headerlink" title="参数设置说明"></a>参数设置说明</h2><h3 id="lt-beehive-service-x2F-gt-标签"><a href="#lt-beehive-service-x2F-gt-标签" class="headerlink" title="&lt;beehive:service&#x2F;&gt; 标签"></a>&lt;beehive:service&#x2F;&gt; 标签</h3><ul>
<li><p>id：为 bean 在 spring 容器中的唯一标识符</p>
</li>
<li><p>service：将要发布的服务，值为你想要发布的服务的全限定名</p>
</li>
<li><p>ref：你所发布服务的实现类，它的值为 spring &lt;bean&#x2F;&gt; 标签的 id 值</p>
</li>
<li><p>proxy-factory：服务提供端代理类创建的方式，目前支持 javassist 和 jdk 可选</p>
</li>
<li><p>serializer：序列化器，默认为 fastjson，可选 hessian</p>
</li>
<li><p>server-port：服务启动的端口号，默认使用 7440，你也可以再启动程序时通过 -Dport&#x3D;端口号 来指定，优先级最高</p>
</li>
</ul>
<h3 id="lt-beehive-reference-x2F-gt-标签"><a href="#lt-beehive-reference-x2F-gt-标签" class="headerlink" title="&lt;beehive:reference&#x2F;&gt; 标签"></a>&lt;beehive:reference&#x2F;&gt; 标签</h3><ul>
<li><p>id：为 bean 在 spring 容器中的唯一标识符</p>
</li>
<li><p>service：将要发布的服务，值为你想要发布的服务的全限定名</p>
</li>
<li><p>load-balance：负载均衡设置，由客户端实现，目前只支持 random 和 poll 两种方式</p>
</li>
<li><p>proxy-factory：服务提供端代理类创建的方式，目前支持 javassist 和 jdk 可选</p>
</li>
<li><p>serializer：序列化器，默认为 fastjson，可选 hessian</p>
</li>
<li><p>read-timeout：指定 rpc 结果读取超时时间，如果本次结果获取失败，将会重试</p>
</li>
<li><p>retry-times：指定重试次数，即 rpc 结果获取超时重试次数</p>
</li>
</ul>
<h3 id="lt-beehive-registry-x2F-gt-标签"><a href="#lt-beehive-registry-x2F-gt-标签" class="headerlink" title="&lt;beehive:registry&#x2F;&gt; 标签"></a>&lt;beehive:registry&#x2F;&gt; 标签</h3><ul>
<li><p>id：为 bean 在 spring 容器中的唯一标识符</p>
</li>
<li><p>address：注册中心的地址，目前只支持 zookeeper，格式如 “zookeeper:&#x2F;&#x2F;host:port”</p>
</li>
</ul>
<h2 id="样例测试"><a href="#样例测试" class="headerlink" title="样例测试"></a>样例测试</h2><h3 id="基本测试"><a href="#基本测试" class="headerlink" title="基本测试"></a>基本测试</h3><p>项目中提供了实例程序（位于 beehive-demo）模块下，通过 git clone 将工程拉取下来后，在根目录下输入如下指令进行安装。</p>
<blockquote>
<p>mvn clean install -Dmaven.test.skip&#x3D;true</p>
</blockquote>
<p>因为需要用到注册中心，所以实例程序中注册中心的地址是我的阿里云服务器地址，正常情况下我会启动 zookeeper 服务，那么示例程序就会将服务注册到我的阿里云服务器的 zookeeper 上，当然你也可以在本机启动一个 zookeeper，然后修改 spring 配置文件中的注册中心地址。</p>
<p>启动服务器，如果你没有修改实例程序的配置文件，默认使用我阿里云的 zookeeper，输入如下指令：</p>
<blockquote>
<p>java -jar beehive-demo&#x2F;provider&#x2F;target&#x2F;provider-1.0-SNAPSHOT-jar-with-dependencies.jar</p>
</blockquote>
<p>启动客户端，没有修改代码的情况下，会从注册中心获取服务信息，输入如下指令：</p>
<blockquote>
<p>java -jar beehive-demo&#x2F;consumer&#x2F;target&#x2F;consumer-1.0-SNAPSHOT-jar-with-dependencies.jar</p>
</blockquote>
<p>如果过程没有错误的话，在控制台将会打印 rpc 的结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result: Jim say world - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">1</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">2</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">3</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">4</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">5</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">6</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">7</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">8</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">9</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br></pre></td></tr></table></figure>

<p>或者启动多线程的 consumer，输入如下指令：</p>
<blockquote>
<p>java -cp beehive-demo&#x2F;consumer&#x2F;target&#x2F;consumer-1.0-SNAPSHOT-jar-with-dependencies.jar top.aprilyolies.consumer.MultiThreadConsumer</p>
</blockquote>
<p>我这里是启动了 5 个线程来进行的 rpc 请求，参数附带了当前线程的信息，所以 rpc 的结果也包含了线程信息，结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">3</span> - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">3</span> - <span class="number">1</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">1</span> - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">4</span> - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">5</span> - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">2</span> - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">3</span> - <span class="number">2</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">1</span> - <span class="number">1</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">2</span> - <span class="number">1</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">5</span> - <span class="number">1</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="服务切换的测试"><a href="#服务切换的测试" class="headerlink" title="服务切换的测试"></a>服务切换的测试</h3><p>示例程序中提供了两个服务端程序，表示两个服务提供者，测试服务切换需要同时启动这两个程序，指令如下：</p>
<blockquote>
<p>java -cp beehive-demo&#x2F;provider&#x2F;target&#x2F;provider-1.0-SNAPSHOT-jar-with-dependencies.jar top.aprilyolies.provider.Provider</p>
</blockquote>
<blockquote>
<p>java -cp beehive-demo&#x2F;provider&#x2F;target&#x2F;provider-1.0-SNAPSHOT-jar-with-dependencies.jar top.aprilyolies.provider.AnotherProvider</p>
</blockquote>
<p>启动客户端，没有修改代码的情况下，会从注册中心获取服务信息，输入如下指令：</p>
<blockquote>
<p>java -jar beehive-demo&#x2F;consumer&#x2F;target&#x2F;consumer-1.0-SNAPSHOT-jar-with-dependencies.jar</p>
</blockquote>
<p>因为测试程序中默认使用的是轮询负载均衡机制，所以客户端会从所有的服务提供者中逐个调用，得到的结果如下，根据最后的 server<br>id 就能够分辨出来当前是请求的哪个服务提供者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result: Jim say world - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">1</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.2</span>]</span><br><span class="line">result: Jim say world - <span class="number">2</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">3</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.2</span>]</span><br><span class="line">result: Jim say world - <span class="number">4</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">5</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.2</span>]</span><br><span class="line">result: Jim say world - <span class="number">6</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">7</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.2</span>]</span><br><span class="line">result: Jim say world - <span class="number">8</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say world - <span class="number">9</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.2</span>]</span><br></pre></td></tr></table></figure>

<p>或者启动多线程的 consumer，输入如下指令：</p>
<blockquote>
<p>java -cp beehive-demo&#x2F;consumer&#x2F;target&#x2F;consumer-1.0-SNAPSHOT-jar-with-dependencies.jar top.aprilyolies.consumer.MultiThreadConsumer</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">2</span> - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">2</span> - <span class="number">1</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.2</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">4</span> - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">1</span> - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">5</span> - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">3</span> - <span class="number">0</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">2</span> - <span class="number">2</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.1</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">3</span> - <span class="number">1</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.2</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">5</span> - <span class="number">1</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.2</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">1</span> - <span class="number">1</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.2</span>]</span><br><span class="line">result: Jim say MultiThreadConsumer-pool-thread-<span class="number">4</span> - <span class="number">1</span> from <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>, [ server id is No<span class="number">.2</span>]</span><br></pre></td></tr></table></figure>

<p>可以看到多线程的环境下，rpc 的调用逻辑和单线程是保持一致的。</p>
<p>实例程序默认是使用的轮询负载均衡机制，如果过程没错的话，那么你将会看到客户端会交替的从两个 provider 进行 rpc 调用。</p>
<p>尝试关掉其中一个 provider，客户端会侦测到这个变化，随即将这个下线的 provider 剔除，仅仅从剩下的 provider 中进行 rpc 调用。</p>
<p>再尝试重启这个 provider，客户端也会侦测到这个变化，随即将这个 provider 加入到可调用的 providers 列表中，进而进行 rpc 调用。</p>
<h2 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h2><h3 id="标签解析"><a href="#标签解析" class="headerlink" title="标签解析"></a>标签解析</h3><p>beehive 实现了自己的标签解析器，spring 容器能够对这些标签对应的 bean 的创建及初始化进行管理，beehive 自定义的标签只有 &lt;beehive:registry&#x2F;&gt;、&lt;beehive:service&#x2F;&gt;、&lt;beehive:reference&#x2F;&gt; 三个，分别对应注册中心、服务发布、服务调用三个逻辑，相应的 BeanDefinitionParser 是由 <code>top.aprilyolies.beehive.spring.namespace.BeehiveNamespaceHandler</code> 完成注册的，它的代码内容如下，就是为每个 beehive 对应的标签注册了一个 BeanDefinitionParser，用于解析 spring 配置文件中的 beehive 标签。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeehiveNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// beehive:registry 标签解析器</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;registry&quot;</span>, <span class="keyword">new</span> <span class="title class_">RegistryBeanDefinitionParser</span>());</span><br><span class="line">        <span class="comment">// beehive:service 标签解析器</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;service&quot;</span>, <span class="keyword">new</span> <span class="title class_">ServiceBeanDefinitionParser</span>());</span><br><span class="line">        <span class="comment">// beehive:reference 标签解析器</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;reference&quot;</span>, <span class="keyword">new</span> <span class="title class_">ReferenceBeanDefinitionParser</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为三个 BeanDefinitionParser 的基本逻辑一样，我这里仅以 ServiceBeanDefinitionParser 进行大致说明，先贴出 ServiceBeanDefinitionParser 的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanDefinitionParser</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建 RootBeanDefinition，用于承载解析出来的信息</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        <span class="comment">// 指定解析的 bean 的类型</span></span><br><span class="line">        beanDefinition.setBeanClass(ServiceProvider.class);</span><br><span class="line">        <span class="comment">// 不使用懒加载</span></span><br><span class="line">        beanDefinition.setLazyInit(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">service</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        beanDefinition.getPropertyValues().addPropertyValue(<span class="string">&quot;service&quot;</span>, service);</span><br><span class="line">        <span class="comment">// 如果没有指定 id 属性</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(id)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            beanDefinition.getPropertyValues().addPropertyValue(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">            <span class="comment">// 尝试使用 name 来确定 id 信息</span></span><br><span class="line">            <span class="keyword">if</span> (!isExisted(parserContext, name)) &#123;</span><br><span class="line">                id = name;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// name 不行的话，那么就使用 service 来确定 id 信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> getBeanName(service);</span><br><span class="line">                id = beanName;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (isExisted(parserContext, id)) &#123;</span><br><span class="line">                    id = beanName + count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(id)) &#123;</span><br><span class="line">            <span class="comment">// 相同 id 只能存在一个</span></span><br><span class="line">            <span class="keyword">if</span> (isExisted(parserContext, id)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(String.format(<span class="string">&quot;Bean of id %s has existed&quot;</span>, id));</span><br><span class="line">            &#125;</span><br><span class="line">            beanDefinition.getPropertyValues().addPropertyValue(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">            <span class="comment">// 进行注册信息，这一步一定不能落下</span></span><br><span class="line">            parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析 protocol 属性</span></span><br><span class="line">        parseAttribute(element, beanDefinition, <span class="string">&quot;protocol&quot;</span>, <span class="string">&quot;beehive&quot;</span>);</span><br><span class="line">        <span class="comment">// 解析 proxy 属性</span></span><br><span class="line">        parseAttribute(element, beanDefinition, <span class="string">&quot;proxy-factory&quot;</span>, <span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">        <span class="comment">// 解析 serializer 属性</span></span><br><span class="line">        parseAttribute(element, beanDefinition, <span class="string">&quot;serializer&quot;</span>, <span class="string">&quot;fastjson&quot;</span>);</span><br><span class="line">        <span class="comment">// 解析 serializer 属性</span></span><br><span class="line">        parseAttribute(element, beanDefinition, <span class="string">&quot;server-port&quot;</span>, <span class="string">&quot;7440&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ref</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果 setter 方法对应的属性为 ref，并且 spring 容器中已经注册过这个 ref 所引用的 bean 的 beanDefinition</span></span><br><span class="line">        <span class="keyword">if</span> (parserContext.getRegistry().containsBeanDefinition(ref)) &#123;</span><br><span class="line">            <span class="comment">// 那就拿到这个 beanDefinition</span></span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">refBean</span> <span class="operator">=</span> parserContext.getRegistry().getBeanDefinition(ref);</span><br><span class="line">            <span class="comment">// 这个 beanDefinition 必须是单例的</span></span><br><span class="line">            <span class="keyword">if</span> (!refBean.isSingleton()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The exported service ref &quot;</span> + ref + <span class="string">&quot; must be singleton! Please set the &quot;</span> + ref + <span class="string">&quot; bean scope to singleton, eg: &lt;bean id=\&quot;&quot;</span> + ref + <span class="string">&quot;\&quot; scope=\&quot;singleton\&quot; ...&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RuntimeBeanReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(ref);</span><br><span class="line">        beanDefinition.getPropertyValues().addPropertyValue(<span class="string">&quot;ref&quot;</span>, reference);</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类实现了 <code>org.springframework.beans.factory.xml.BeanDefinitionParser</code> 接口，他只有一个 <code>BeanDefinition parse(Element element, ParserContext parserContext);</code> 方法，参数 element 就是 spring 配置文件中 beehive 对应的那个标签元素，参数 parserContext 就是一个标签解析的上下文环境，可以从中获取到已经解析的标签的信息。在 parse 方法中我们就需要实现自己的标签解析逻辑，主要就是创建了一个 RootBeanDefinition 实例，然后将其和正在解析的标签所对应的类进行绑定，也就是 <code>beanDefinition.setBeanClass(ServiceProvider.class);</code> 这个方法，接下来就是将标签中解析出来的属性逐个的添加到刚刚创建的 RootBeanDefinition 实例中，这样 RootBeanDefinition 就包含了类信息及相关的参数信息，最后就是将 RootBeanDefinition 实例返回，交由 spring 容器进行管理，这包括 bean 是否是单例，不同的初始化阶段的声明周期方法的调用，字段的自动装配等等。</p>
<h3 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h3><p>服务端启动主要是完成了三件事，打开数据通信服务器、创建服务接口服务端代理，向注册中心发布服务，执行的先后顺序如下图：</p>
<div style="text-align:center;"><img src="https://img.aprilyolies.top/img/typora/6bf986c768b463921ee0e5d01d9992ed.jpeg" width=600 /></div>

<center>服务端启动核心逻辑</center>


<p>在完成标签的解析后，标签对应的 bean 就会交由 spring 容器管理，根据 bean 的实现接口的类型，spring 容器会在不同的阶段完成 bean 对应接口方法的调用，服务端的启动就是如此。先看看服务发布标签对应 bean（ServiceProvider）的实现接口 <code>public class ServiceProvider extends ServiceConfigBean implements ApplicationListener&lt;ContextRefreshedEvent&gt;, InitializingBean, ApplicationContextAware</code>，对于 ApplicationListener 接口的实现类，spring 容器在初始化完成后进行该接口对应方法的调用，InitializingBean 接口则是在进行 bean 的初始化时进行调用，而 ApplicationContextAware 是一个感知接口，就是该接口的实现类能够拿到 spring 上下文环境，在 beehive 中，则是利用该接口拿到了 spring 上下文环境，通过它注册了一个关闭钩子函数，用于关闭通信端程序。具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    <span class="comment">// 注册关闭监听器</span></span><br><span class="line">    <span class="comment">// 如果 context 是 ConfigurableApplicationContext 接口的实例</span></span><br><span class="line">    <span class="keyword">if</span> (applicationContext <span class="keyword">instanceof</span> ConfigurableApplicationContext) &#123;</span><br><span class="line">        <span class="comment">// spring 框架的方法，向 jvm 注册一个关闭钩子函数，在 jvm 关闭时会调用这个钩子函数来关闭 applicationContext</span></span><br><span class="line">        ((ConfigurableApplicationContext) applicationContext).registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册关闭监听器</span></span><br><span class="line">    addApplicationListener(<span class="keyword">new</span> <span class="title class_">ShutdownHookListener</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * beehive 的关闭监听器，它会监听 context 关闭事件，同时关闭相关的组件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 此监听器只会监听 context 关闭事件</span></span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            BeehiveShutdownHook.closeAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭注册的 Registry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Registry registry : registries) &#123;</span><br><span class="line">        registry.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (EndPoint endPoint : endPoints) &#123;</span><br><span class="line">        endPoint.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而实现 InitializingBean 接口主要是为了注入 registry 对应的 bean 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用于为当前 bean 填充一些必要属性</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    checkRegistry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检查当前 bean 的 registry 属性是否为空，否则从 spring 容器中获取对应的值进行填充</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RegistryConfigBean</span> <span class="variable">registry</span> <span class="operator">=</span> getRegistry();</span><br><span class="line">    <span class="keyword">if</span> (registry == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            Map&lt;String, RegistryConfigBean&gt; registryMap = BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext,</span><br><span class="line">                    RegistryConfigBean.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (registryMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 spring 容器中有多个 registry bean，那么优先获取第一个</span></span><br><span class="line">                Collection&lt;RegistryConfigBean&gt; registries = registryMap.values();</span><br><span class="line">                <span class="keyword">for</span> (RegistryConfigBean reg : registries) &#123;</span><br><span class="line">                    setRegistry(reg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端启动的主要逻辑是在 ApplicationListener 接口对应的方法中完成的，该方法中直接是调用了 <code>exportService();</code> 方法，该方法中主要是两个部分，准备 registryUrls 和进行真正的服务注册，准备 registryUrls 就只是一个信息拼凑的过程，逻辑简单，只是过程比较繁琐，感兴趣的话可以自行去看<a class="link"   target="_blank" rel="noopener" href="https://github.com/AprilYoLies/beehive" >源码<i class="fas fa-external-link-alt"></i></a>，最终的拼凑结果我通过 debug 的方式显示出来了，请看下图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">    exportService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!published) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (publishMonitor) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!published) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Export service via thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前实例以 provider_model 的形式保存到 BeehiveContext 中</span></span><br><span class="line">                BeehiveContext.unsafePut(UrlConstants.PROVIDER_MODEL, <span class="built_in">this</span>);</span><br><span class="line">                <span class="comment">// 根据 registry 属性构建 registry urls</span></span><br><span class="line">                List&lt;URL&gt; registryUrls = getRegistryUrl(getRegistry());</span><br><span class="line">                <span class="comment">// 将当前实例中的属性填充到 url 的参数中</span></span><br><span class="line">                fillParameters(registryUrls, <span class="built_in">this</span>);</span><br><span class="line">                <span class="comment">// 检查 registry url 是否包含必要的属性</span></span><br><span class="line">                checkRegistryUrls(registryUrls);</span><br><span class="line">                <span class="comment">// 进行真正的服务注册</span></span><br><span class="line">                registryService(registryUrls);</span><br><span class="line">            &#125;</span><br><span class="line">            published = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="text-align:center;"><img src="https://img.aprilyolies.top/img/typora/77fcba48c4ee4aaf1678c0ba52d90d63.jpeg" width=700 /></div>

<center>registryUrls的内容</center>

<p>这里重点关注第二部分进行真正的服务注册方法 <code>registryService(registryUrls);</code>，它根本是调用的 <code>AbstractRegistry#registry</code> 方法，在该方法中主要就是完成了服务端启动的三个核心逻辑，从其方法名就可以知道了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registry</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Can&#x27;t publish a service for null url&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        openServer(url);</span><br><span class="line">        createInvoker(url);</span><br><span class="line">        doPublish(url);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;publish service failed&quot;</span>, e.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看 <code>openServer(url);</code> 方法，它会根据 url 确定当前终端是服务端还是客户端，因为我们现在是分析的服务端启动，所以走的是上边那条逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">openServer</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> url.getOriginUrl().getParameterElseDefault(UrlConstants.SERVICE_PROTOCOL, UrlConstants.DEFAULT_SERVICE_PROTOCOL);</span><br><span class="line">    <span class="type">URL</span> <span class="variable">serviceUrl</span> <span class="operator">=</span> URL.copyFromUrl(url.getOriginUrl());</span><br><span class="line">    serviceUrl.setOriginUrl(url.getOriginUrl());</span><br><span class="line">    serviceUrl.setProtocol(protocol);</span><br><span class="line">    <span class="keyword">if</span> (url.isProvider()) &#123;</span><br><span class="line">        protocolSelector.publish(serviceUrl);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!url.isProvider()) &#123;</span><br><span class="line">        protocolSelector.subscribe(serviceUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的实现是这样的，优先从缓存中获取 server 实例，如果没有的话就新建一个 server 实例并进行缓存，server 实例的创建是在 NettyTransporter#bind 方法中完成的，可以看到这里创建的是一个 NettyServer，也就是说 beehive 的底层是采用的 netty 作为通信框架的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Server <span class="title function_">bind</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serverKey</span> <span class="operator">=</span> buildServerKey(url);</span><br><span class="line">    <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> serverCache.get(serverKey);</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (serverCache) &#123;</span><br><span class="line">            <span class="keyword">if</span> (serverCache.get(serverKey) == <span class="literal">null</span>) &#123;</span><br><span class="line">                server = <span class="keyword">new</span> <span class="title class_">NettyServer</span>(url);</span><br><span class="line">                AbstractConfig.BeehiveShutdownHook.addEndPoint(server);</span><br><span class="line">                serverCache.putIfAbsent(serverKey, server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道 <code>openServer(url);</code> 的实现后，再看 <code>createInvoker(url);</code> 方法，它就是一个创建服务接口代理类的过程，考虑到拓展性，所以 beehive 的处理过程还将创建出来的代理进行了封装，最终返回的是一个 Invoker 链，我们先看看根本的代理类的创建过程，它的实现是在 <code>AbstractProxyFactory#createInvoker</code> 方法中，里边有两个逻辑，创建原生的代理类，和将代理类封装成为 Invoker 实现类，这样做是为了方便后边的 Invoker 链的构建。beehive 提供了两种代理类生成的方式，这里只是为了说明代理的逻辑，所以选择稍微简单的 jdk 原生代理的方式进行说明，而 javassist 方式生成代理的过程可以自行参考源码理解。</p>
<p>jdk 原生代理类生成的入口方法为 <code>JdkProxyFactory#createProxy</code>，我们是服务端代理类生成，走上一个分支，可以看到它根本是调用的 <code>ProviderProxy.getJdkProxy(target, clazz, Proxy.class);</code> 方法，其中 target 就是我们在 spring 配置文件中指定的服务接口的实现类，class 是服务接口对应的 class，而 Proxy.class 则是返回的接口类型，也就是说我们生成的代理类是实现了两个接口的，服务接口和 Proxy 接口，且返回的表现形式是 Proxy。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Proxy <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; clazz, URL url)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (url.isProvider()) &#123;</span><br><span class="line">        <span class="comment">// 根据 url 信息获取 invoke target 实例</span></span><br><span class="line">        <span class="type">ServiceConfigBean</span> <span class="variable">serviceConfigBean</span> <span class="operator">=</span> BeehiveContext.unsafeGet(UrlConstants.PROVIDER_MODEL, ServiceConfigBean.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> serviceConfigBean.getRef();</span><br><span class="line">        <span class="keyword">return</span> ProviderProxy.getJdkProxy(target, clazz, Proxy.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> getInvoker(url);</span><br><span class="line">        <span class="keyword">return</span> ConsumerProxy.getJdkProxy(<span class="keyword">new</span> <span class="title class_">InvokerInvocationHandler</span>(invoker, url), clazz, Proxy.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道这一点后，我们再直接看 jdk 代理类的构建细节，也就是如下代码所示的那样，可以看到代理的逻辑是由 ProviderInvocationHandler 指定的，它持有了我们在 spring 配置文件中指定的服务接口的实现类，当代理类需要执行某个方法时，真正调用的其实是服务接口实现类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建 jdk 代理类</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> classes</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title function_">getJdkProxy</span><span class="params">(Object target, Class&lt;?&gt;... classes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (classes.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t create jdk proxy for none of interface has specified&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> classes[<span class="number">0</span>].getClassLoader();</span><br><span class="line">    <span class="type">ProviderInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderInvocationHandler</span>(target);</span><br><span class="line">    <span class="keyword">return</span> (Proxy) java.lang.reflect.Proxy.newProxyInstance(classLoader, classes, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * provider 的 jdk invocation handler</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProviderInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProviderInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的 jdk 代理是是被封装成了 ProxyWrapperInvoker，beehive 接下来就是根据该 invoker 构建 invoker 链，至于 invoker 链的其他节点，则是通过 spi 拓展机制来指定的，但是关于 invoker 逻辑功能，我暂时是做的空实现，所以采用的是硬编码的方式，如果以后有新的需求了，就会考虑将其实现改为适配 spi 拓展，关乎 invoker 链，这里采用的是责任链模式，具体的构建过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过 filter 构建 invoker 链，最后一个 invoker 就是我们创建的 ProxyWrapperInvoker，它封装了我们真正的调用逻辑</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> invoker 原始的 invoker</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 通过 filter 构建出来的 invoker 链</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Invoker <span class="title function_">buildInvokerChain</span><span class="params">(Invoker&lt;?&gt; invoker)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 这里的 filter 获取应该通过 ExtensionLoader</span></span><br><span class="line">    List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    filters.add(<span class="keyword">new</span> <span class="title class_">AccessLogFilter</span>());</span><br><span class="line">    filters.add(<span class="keyword">new</span> <span class="title class_">MonitorFilter</span>());</span><br><span class="line">    <span class="type">Invoker</span> <span class="variable">ptr</span> <span class="operator">=</span> invoker;</span><br><span class="line">    <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Invoker</span> <span class="variable">next</span> <span class="operator">=</span> ptr;</span><br><span class="line">            <span class="type">Invoker</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractInvoker</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> Object <span class="title function_">doInvoke</span><span class="params">(InvokeInfo info)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> filter.doFilter(next, info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            ptr = pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到封装我们代理类的 ProxyWrapperInvoker 节点位于 invoker 链的末尾，而最终返回的是 invoker 链的头结点，这样在进行逻辑调用时，就会先执行拓展逻辑，最后再执行我们的代理逻辑。</p>
<p>最后一个就是 <code>doPublish(url);</code> 方法，它做的事情很简单，就是向注册中心也就是 zookeeper 中写入当前发布的服务的相关信息，这里的 zookeeper 客户端使用的 curator 框架，具体的过程很简单，这里只给出写入服务信息后的结果。</p>
<div style="text-align:center;"><img src="https://img.aprilyolies.top/img/typora/e910e07480c308a547a32e3deb9ce2d2.jpeg" width=600 /></div>

<center>zookeeper 中写入的服务信息</center>

<p>执行到这里，服务端的启动计算完成了，这个启动过程主要就是做了三件事情，启动数据交互的服务终端，创建逻辑调用的代理类，将其封装为 Invoker 链，之后就是向注册中心发布服务，接下来继续读客户端的启动进行说明。</p>
<h3 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h3><p>在了解过服务端的启动之后，再看客户端的启动流程就会很简单，跟客户端一样，它主要也是实现了三个逻辑，在这三个逻辑中，就只有代理类的创建比较复杂，而在数据交互的终端创建和消费者信息注册方面，过程基本一致，所以这里主要就是对代理类的创建方式进行说明。</p>
<div style="text-align:center;"><img src="https://img.aprilyolies.top/img/typora/1abf28803db922098c76f7502c068ada.jpeg" width=600 /></div>

<center>客户端启动核心逻辑</center>

<p>首先还是看和服务调用相关的标签 &lt;beehive:reference&#x2F;&gt; 对应的 bean（ServiceConsumer）所实现的接口，相比于服务端，客户端实现的接口就只有一个 FactoryBean，它指定了三个方法，根据 spring 的实现规则，知道在获取实现 FactoryBean 接口的 bean 时，它实际返回的是 <code>getObject()</code> 方法返回的实例。根据这个特性，所以 beehive 客户端的服务接口代理类就是通过该方法返回的，我们重点关注这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">	T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getObject()</code> 方法和服务端的 <code>ServiceProvider#onApplicationEvent</code> 方法很相似，分为准备 registryUrls 信息和订阅 registryUrl 两部分（客户端的订阅和服务端的发布相对应），准备 registryUrls 信息的过程就是个简单但是比较繁琐的过程，可以自行看源码了解，而订阅 registryUrl 的逻辑根本就是调用的 <code>AbstractRegistry#registry</code> 方法，它跟服务端调用的是同样的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registry</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Can&#x27;t publish a service for null url&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        openServer(url);</span><br><span class="line">        createInvoker(url);</span><br><span class="line">        doPublish(url);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;publish service failed&quot;</span>, e.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以客户端启动做的三个核心逻辑和服务端是一样的，只是具体的实现不一样，先看 <code>openServer(url);</code>，它根本是调用的 <code>NettyTransporter#connect</code> 方法，可以看到这里我们创建的是 NettyClient，这和服务端的 NettyServer 对应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Client <span class="title function_">connect</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    <span class="type">NettyClient</span> <span class="variable">nettyClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyClient</span>(url);</span><br><span class="line">    AbstractConfig.BeehiveShutdownHook.addEndPoint(nettyClient);</span><br><span class="line">    <span class="keyword">return</span> nettyClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看 <code>createInvoker(url);</code> 方法的实现，我们这里启动客户端，所以走的是 else 分支，首先代码是从 zookeeper 注册中心中获取已经发布的服务信息，也就是服务端所发布的服务信息。接着调用 <code>ZookeeperRegistry#addProviderRefreshListener</code> 方法，其实就是通过 curator 框架向 zookeeper 注册了一个监听器，它会监听服务上下线的信息，以此来达到更新 provider 列表的目的，关键的代码如下，添加的 listener 为 ProviderRefreshListener，可以看到它监听 CHILD_ADDED、CHILD_REMOVED、CHILD_UPDATED 三种事件，所作出的动作是 <code>BeehiveContext.unsafePut(PROVIDERS, providerUrls);</code> 更新 provider 列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 为 consumer 添加一个监听器，用于监测 provider 更新消息</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> providerPath</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addProviderRefreshListener</span><span class="params">(String providerPath)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">PathChildrenCache</span> <span class="variable">pathCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(zkClient, providerPath, <span class="literal">true</span>);</span><br><span class="line">        pathCache.start();</span><br><span class="line">        pathCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">ProviderRefreshListener</span>(pathCache));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Add provider refresh listener failed, the target path was &quot;</span> + providerPath + <span class="string">&quot;, the curator client was &quot;</span> + zkClient);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 该 listener 用于刷新 provider 信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ProviderRefreshListener</span> <span class="keyword">implements</span> <span class="title class_">PathChildrenCacheListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PathChildrenCache pathCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProviderRefreshListener</span><span class="params">(PathChildrenCache pathCache)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pathCache = pathCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        PathChildrenCacheEvent.<span class="type">Type</span> <span class="variable">eventType</span> <span class="operator">=</span> event.getType();</span><br><span class="line">        <span class="comment">// 如果 child 信息发生变化，进行更新</span></span><br><span class="line">        <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">            <span class="keyword">case</span> CHILD_ADDED:</span><br><span class="line">            <span class="keyword">case</span> CHILD_REMOVED:</span><br><span class="line">            <span class="keyword">case</span> CHILD_UPDATED: &#123;</span><br><span class="line">                List&lt;ChildData&gt; currentData = pathCache.getCurrentData();</span><br><span class="line">                List&lt;String&gt; providerUrls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(currentData.size());</span><br><span class="line">                <span class="keyword">for</span> (ChildData data : currentData) &#123;</span><br><span class="line">                    providerUrls.add(data.getPath());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里是保存到 concurrent hash map 中，能够保证可见性</span></span><br><span class="line">                BeehiveContext.unsafePut(PROVIDERS, providerUrls);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就是创建服务接口的客户端代理，这里以 jdk 的客户端代理进行说明，还记得在服务端创建 jdk 代理时有获取一个代理 target 实例吗？它就是服务接口的实现类，完成了具体提服务逻辑。但现在我们是在创建客户端的代理，那么这里的代理 target 实例是什么呢？其实可以先试想一下，我们客户端在调用接口方法时，代理类应该完成啥样的逻辑呢？</p>
<p>beehive 这里的实现其实就是将被调用的接口方法和参数相关信息发送到服务端，服务端再根据收到的方法及参数信息完成真正的服务接口实现类的逻辑调用，最终再将处理的结果返回给客户端代理，最终代理将结果返回给方法调用者，完成这个发送方法及参数信息给服务端的类就是这里应该拿到的 target 实例，通过 debug，可以知道这个实例其实就是 FailoverClusterInvoker。它里边的实现逻辑不是这里应该关注的点，我们只需要知道，客户端的服务接口代理根本是调用的 FailoverClusterInvoker 实例的方法。知道这个后，jdk 代理类的创建就跟服务端一样了，具体到代码就是下边这一段，<code>getInvoker(url)</code> 拿到的是 FailoverClusterInvoker，它将被作为 target 而创建服务端接口代理类。</p>
<blockquote>
<p>top.aprilyolies.beehive.proxy.JdkProxyFactory#createProxy</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> getInvoker(url);</span><br><span class="line"><span class="keyword">return</span> ConsumerProxy.getJdkProxy(<span class="keyword">new</span> <span class="title class_">InvokerInvocationHandler</span>(invoker, url), clazz, Proxy.class);</span><br></pre></td></tr></table></figure>

<p>完成客户端服务接口代理类创建的说明，就只剩下 <code>doPublish(url);</code>，跟服务端一样就是向注册中心写入自身的信息，使用的是 curator 框架，过程很简单，不做细说，只给出写入的结果。</p>
<div style="text-align:center;"><img src="https://img.aprilyolies.top/img/typora/b9de1788fb5447654e1b20191505ba8b.jpeg" width=600 /></div>

<center>zookeeper 中写入的消费者信息</center>

<h3 id="客户端-RPC-请求流程"><a href="#客户端-RPC-请求流程" class="headerlink" title="客户端 RPC 请求流程"></a>客户端 RPC 请求流程</h3><p>当完成客户端和服务端的启动后，客户端就可以进行 rpc 请求了，还记的上文指出的 FailoverClusterInvoker 实例吗？它是客户端代理类真正逻辑的起点。从类名可以知道它是一个 Invoker 类，自然是实现了 Invoker 接口，这样我们关注的也就是该接口对应的 <code>Invoker#invoke</code> 方法，它的实现是在父类 AbstractInvoker 之中，该方法又是调用了 <code>AbstractInvoker#doInvoke</code> 方法，子类负责实现该方法的逻辑，这里是典型的模板方法设计模式。</p>
<p>我先把 <code>FailoverClusterInvoker#doInvoke</code> 方法贴出来，第一个 if 判断实现看看缓存中是否有 invokers 信息，如果没有就会执行 listInvokers 方法来列出可用的 invokers。</p>
<blockquote>
<p>top.aprilyolies.beehive.invoker.FailoverClusterInvoker#doInvoke</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doInvoke</span><span class="params">(InvokeInfo info)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.invokers == <span class="literal">null</span> || registry == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (invokers == <span class="literal">null</span> || registry == <span class="literal">null</span>) &#123;</span><br><span class="line">                    invokers = listInvokers();</span><br><span class="line">                    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> BeehiveContext.unsafeGet(REGISTRIES, Registry.class);</span><br><span class="line">                    addInvokersRefreshListener(<span class="built_in">this</span>.registry);</span><br><span class="line">                    <span class="built_in">this</span>.registry = registry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needUpdateInvokers) &#123;</span><br><span class="line">            updateInvokers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">reInvokeCount</span> <span class="operator">=</span> retryCountThreadLocal.get();</span><br><span class="line">        <span class="type">LoadBalance</span> <span class="variable">loadBalance</span> <span class="operator">=</span> loadBalanceThreadLocal.get();</span><br><span class="line">        <span class="keyword">if</span> (loadBalance == <span class="literal">null</span>) &#123;</span><br><span class="line">            loadBalance = createLoadBalance(url);</span><br><span class="line">            loadBalanceThreadLocal.set(loadBalance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择合适的 invoker</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = selectInvoker(loadBalance, invokers);</span><br><span class="line">        <span class="keyword">if</span> (invoker != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Invoker</span> <span class="variable">chain</span> <span class="operator">=</span> buildInvokerChain(invoker);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> chain.invoke(info);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 辅助刷新 invokers</span></span><br><span class="line">                needUpdateInvokers = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 返回结果为空进行重试</span></span><br><span class="line">                <span class="keyword">if</span> (reInvokeCount++ &lt; MAX_REINVOKE_TIMES) &#123;</span><br><span class="line">                    retryCountThreadLocal.set(reInvokeCount);</span><br><span class="line">                    <span class="keyword">return</span> doInvoke(info);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 重试达到上限，直接返回 null 结果</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Do invoke &quot;</span> + MAX_REINVOKE_TIMES + <span class="string">&quot; times, but the result was still null&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;There is none of service provider could be use, please check your &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;registry center that if there is any service has published.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        retryCountThreadLocal.set(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下就是列出可用 invokers 信息的方法，首先是拿到注册中心上发布的服务信息的集合，在服务端启动时，会首先获取一次该集合并缓存到 BeehiveContext 中，如果后续发生了服务信息的更新即服务的上下线等，客户端启动时注册的监听器会侦测该变化，并刷新服务信息集合。接着就是过滤这些服务信息，因为即便是相同的服务，可能会由于发布服务时使用的编解码方式与客户端使用的编解码方式不一致导致服务不能直接访问，这样该服务也就应该被过滤掉。过滤的条件可以更加细化，如果你有好的建议也可以提交 PR，我看到后会进行处理。完成服务信息的过滤后接着就是获取当前服务对应的通信终端，最后将获取的服务信息和通信终端构建为 RemoteInvoker 返回。</p>
<blockquote>
<p>top.aprilyolies.beehive.invoker.FailoverClusterInvoker#listInvokers</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> List&lt;Invoker&lt;T&gt;&gt; <span class="title function_">listInvokers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; providersMap = BeehiveContext.unsafeGet(UrlConstants.PROVIDERS, Map.class);</span><br><span class="line">    List&lt;String&gt; providers = providersMap.get(url.getParameter(UrlConstants.SERVICE));</span><br><span class="line">    providers = filterProviders(providers);</span><br><span class="line">    <span class="built_in">this</span>.providers = providers;</span><br><span class="line">    <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> BeehiveContext.unsafeGet(UrlConstants.CONSUMERS_TRANSPORT, Client.class);</span><br><span class="line">    <span class="keyword">assert</span> providers != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> createRemoteInvoker(providers, client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FailoverClusterInvoker#doInvoke</code> 的第二个 if 条件是判断是否服务发生了更新，如果发生了更新就需要刷新 invokers 列表，刷新的过程和列出 invokers 列表的逻辑相似，只是这其中涉及到一个集合操作，即剔除下线的服务，新增上线的服务，感兴趣的话可以自己看源代码。</p>
<p>接下来的代码就是从列出的 invokers 列表中选择一个 invoker 构建 invoker 链，然后进行 invoke 调用，选择 invoker 的过程我将其描述为一个负载均衡的过程，默认提供了两种负载均衡策略，随机选取和轮询选取，具体的由 PollLoadBalance 和 RandomLoadBalance 两个类来负责实现，代码也很简单，贴出来自行阅读即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (invokers == <span class="literal">null</span> || invokers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> Math.abs(random.nextInt() % invokers.size());</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;There are &quot;</span> + invokers.size() + <span class="string">&quot; invokers, RandomLoadBalance choose the invoker with&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;index of &quot;</span> + idx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(idx);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Got invoker failed, this may caused by some new provider was added, and the beehive&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; was refresh the invokers list&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PollLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> invokers.size();</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= size) &#123;</span><br><span class="line">            idx = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(idx++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FailoverClusterInvoker#selectInvoker</code> 方法就是通过上述的两个负载均衡器选择一个合适的 invoker 的方法，拿到这个 invoker 后就是构建 invoker 链，这个过程和服务端启动的 invoker 链构建过程一样，这里不再赘述。接着就是调用 invoker 链的 invoke 方法，根据之前的分析我们知道 invoker 链的尾节点就是我们通过负载均衡器选择出来的那个 invoker，也就是我们在 <code>FailoverClusterInvoker#listInvokers</code> 方法中列出的众多 invokers 中的一个，他们都是 RemoteInvoker 实例，所以我们接下来分析该 invoker 的 invoke 方法。</p>
<p>同样的 RemoteInvoker 是继承自 AbstractInvoker 父类，我们关注的是 doInvoke 方法的实现。这里还是先把代码贴出来，考虑到篇幅问题，我这里剃掉了部分空指针判断条件和失败重试代码，只留下了核心代码。简化后的代码可以很清楚的看到核心逻辑就三个，连接服务端，发送 rpc 请求信息，获取响应结果。连接服务端和发送 rpc 请求和 netty 的使用有关，如果不熟悉 netty 需要先自行了解 netty 的使用，本文这里不细述。而这里获取响应的结果是采用的异步的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doInvoke</span><span class="params">(InvokeInfo info)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程的 channelMap</span></span><br><span class="line">        Map&lt;String, Channel&gt; channelMap = addressChannel.get();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">ch</span> <span class="operator">=</span> channelMap.get(channelKey);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="literal">null</span> || !ch.isOpen() || !ch.isActive()) &#123;</span><br><span class="line">            <span class="comment">// 连接服务器</span></span><br><span class="line">            ch = connectServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建 request 消息</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> buildRequest(info);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        ch.writeAndFlush(request);</span><br><span class="line">        <span class="comment">// 获取异步的响应结果</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> getResponse(request);</span><br><span class="line">        <span class="type">String</span> <span class="variable">retryTimes</span> <span class="operator">=</span> <span class="built_in">this</span>.url.getParameter(UrlConstants.RETRY_TIMES);</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> RETRY_TIMES;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(retryTimes)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                times = Integer.parseInt(retryTimes);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取 rpc 结果的入口方法是 <code>RemoteInvoker#getResponse</code>,这里需要明确的一点是每一个 rpc 请求都有它所唯一对应的 id 来标志，rpc 请求结果的异步获取利用了这个特性。进行当前 rpc 请求的线程将本次请求的 id 和一个 RpcResult 形成映射缓存到 BeehiveContext，然后当前线程调用该 RpcResult 的 get 方法来获取结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从 BeehiveContext 中获取异步的响应结果</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">getResponse</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到请求的 id，用于异步获取响应内容</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sid</span> <span class="operator">=</span> String.valueOf(request.getId());</span><br><span class="line">    <span class="comment">// 存根请求结果</span></span><br><span class="line">    BeehiveContext.unsafePut(sid, <span class="keyword">new</span> <span class="title class_">RpcResult</span>());</span><br><span class="line">    <span class="comment">// 异步获取相应结果</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="built_in">this</span>.url.getParameter(UrlConstants.READ_TIMEOUT);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(timeout)) &#123;</span><br><span class="line">            res = BeehiveContext.unsafeGet(sid, RpcResult.class).get();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> Integer.parseInt(timeout);</span><br><span class="line">                res = BeehiveContext.unsafeGet(sid, RpcResult.class).get(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;The timeout parameter &quot;</span> + timeout + <span class="string">&quot; is wrong, use the default timeout 2000ms&quot;</span>);</span><br><span class="line">                res = BeehiveContext.unsafeGet(sid, RpcResult.class).get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// empty</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除缓存</span></span><br><span class="line">    BeehiveContext.unsafeRemove(sid);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下边列出了 RpcResult 的 get 方法，可以看到这里使用了 Condition 来完成线程之间的通信。如果 rpc 请求过程的完成标志 finished 为 false，进行 get 方法的当前线程会进行限时阻塞。如果在阻塞的过程中 rpc 过程完成，当前被阻塞的线程会被唤醒继续之前的逻辑。如果发生超时，那么之前的代码会根据情况进行请求的重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 带延时的获取相应的结果</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> timeout 延时时长</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 相应的结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.msg;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (!finished) &#123;</span><br><span class="line">                finishCondition.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (!finished) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Get result was timeout&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.msg;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Get result was interrupted&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Get result was interrupted&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步获取 rpc 请求的结果的方式就是这样，这里有个疑问是谁来负责唤醒当前的阻塞线程呢？这个就需要牵涉到 netty 的 channel handler 对于 rpc 结果的处理了，这里我们只需要知道如果 rpc 结果在有限时长内完成，那么当前线程会顺利的返回 rpc 的结果，如果超时就会进行重试，而负责唤醒当前阻塞线程的其它线程是跟 netty 有关的。</p>
<h3 id="netty-通信客户端"><a href="#netty-通信客户端" class="headerlink" title="netty 通信客户端"></a>netty 通信客户端</h3><p>上边说到了进行 rpc 请求的线程在通过 netty 发送 rpc 信息后，调用 get 方法会阻塞在 rpc 结果的获取方法上，这部分即对 rpc 信息的发送编码过程进行说明，这里需要先明确 rpc 的信息是由 Request 实例承载的，我这里通过 debug 的方式给出一个 Request 实例的样例。可以看到其中就两个字段，消息的类型和 RPCINFO，里边包括了请求的方法名、参数的类型、参数的值以及服务的全限定名，通过这几项值就可以唯一确定服务的具体实现了。</p>
<div style="text-align:center;"><img src="https://img.aprilyolies.top/img/typora/df15b2d51fdbe77b0cbc98a6b9870bd7.jpeg" width=600 /></div>

<center>Request 内部数据实例</center>

<p>上文只是说了 NettyClient 的构建，但是具体的内容没有说明，其实关于 netty 客户端的创建，我们需要关心的就是 ChannelInitializer 对于 NioSocketChannel 的初始化过程，具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline()<span class="comment">//.addLast(&quot;logging&quot;,new LoggingHandler(LogLevel.INFO))//for debug</span></span><br><span class="line">        .addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">NettyDecoderHandler</span>(getUrl()))   <span class="comment">// 指定 decoder -&gt; InternalDecoder</span></span><br><span class="line">        .addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">NettyEncoderHandler</span>(getUrl()))   <span class="comment">// 指定 encoder -&gt; InternalEncoder</span></span><br><span class="line">        <span class="comment">// 该处理器用于向服务器发送心跳消息</span></span><br><span class="line">        .addLast(<span class="string">&quot;client-idle-handler&quot;</span>, <span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(HEARTBEAT_INTERVAL, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.MILLISECONDS))</span><br><span class="line">        .addLast(<span class="string">&quot;heartbeat-handler&quot;</span>, <span class="keyword">new</span> <span class="title class_">HeartbeatHandler</span>())   <span class="comment">// 该处理器主要是对心跳消息进行处理</span></span><br><span class="line">        .addLast(<span class="string">&quot;handler&quot;</span>, <span class="keyword">new</span> <span class="title class_">ClientFinalChannelHandler</span>(getUrl()));    <span class="comment">// 最后的 handler，就是核心的逻辑处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里的 IdleStateHandler 和 HeartbeatHandler 是和心跳消息相关联的，感兴趣可以自行阅读，对于我们的 Request 实例的发送和响应的接收而言，只跟 另外三个 ChannelHandler 相关，因为我们现在是发送 Request 包，直接定位到 <code>NettyEncoderHandler#encode</code> 方法如下，至于为什么会调用该方法，这就和 netty 的 channel pipeline 上的 channel handler context 与 channel handler 有关了，如果对 netty 的源码不熟，就会很难理解，如果有时间我后边会写一些关于 netty 源码的文章。好了，我们这里是 Request，走 <code>requestEncode(ctx, msg, out);</code> 分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    serializer = extensionSelector.serializer(url, out);</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        requestEncode(ctx, msg, out);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">        responseEncode(ctx, msg, out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的代码如下，其实每一步我在注释中已经写得很详细了，我这里只要给出数据包的模型就能够很容易理解编码的过程，唯一要注意的是我们这里的 Request 是 RpcRequest，所以在进行数据包体的编码时，是从 Request 中获取到 data 即 RpcInfo 进行编码。</p>
<table>
<thead>
<tr>
<th align="left">魔幻数字（0 - 1）</th>
<th align="left">标志位（2）</th>
<th align="left">保留位（3）</th>
<th align="left">序列号（4 - 11）</th>
<th align="left">数据包体长度（12 - 15）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">占用 2 字节</td>
<td align="left">占用 1 字节</td>
<td align="left">占用 1 字节</td>
<td align="left">占用 8 字节</td>
<td align="left">占用 4 字节</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">requestEncode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request) msg;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Encode request message of &quot;</span> + request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建请求头</span></span><br><span class="line">    <span class="type">byte</span>[] header = <span class="keyword">new</span> <span class="title class_">byte</span>[HEADER_LENGTH];</span><br><span class="line">    <span class="comment">// 填充魔幻数字</span></span><br><span class="line">    ByteUtils.fillShort(MAGIC, header, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 填充请求头的标志字节</span></span><br><span class="line">    header[<span class="number">2</span>] = (<span class="type">byte</span>) (REQUEST_FLAG | extensionSelector.getSerializerId(url));</span><br><span class="line">    <span class="comment">// 填充请求 id</span></span><br><span class="line">    ByteUtils.fillLong(request.getId(), header, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 这是 header 的起始位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">headerIndex</span> <span class="operator">=</span> out.writerIndex();</span><br><span class="line">    <span class="comment">// 将 writer 指针定位到 body 写入的起始位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bodyIndex</span> <span class="operator">=</span> headerIndex + HEADER_LENGTH;</span><br><span class="line">    out.writerIndex(bodyIndex);</span><br><span class="line">    <span class="comment">// 对于 rpc 请求的编码和事件消息的编码是不一样的</span></span><br><span class="line">    <span class="keyword">if</span> (request.isEvent()) &#123;</span><br><span class="line">        header[<span class="number">2</span>] = (<span class="type">byte</span>) (header[<span class="number">2</span>] | EVENT_FLAG);</span><br><span class="line">        encodeEventRequest(request.getData());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        encodeRpcRequest(request.getData());</span><br><span class="line">    &#125;</span><br><span class="line">    serializer.flushBuffer();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> out.writerIndex() - bodyIndex;</span><br><span class="line">    <span class="comment">// 填充 header 的长度信息</span></span><br><span class="line">    ByteUtils.fillInt(len, header, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">// 将位置定位到 header 起始位置</span></span><br><span class="line">    out.writerIndex(headerIndex);</span><br><span class="line">    <span class="comment">// 写入头信息</span></span><br><span class="line">    out.writeBytes(header);</span><br><span class="line">    <span class="comment">// 将指针定位到全部数据写入后应该在的位置</span></span><br><span class="line">    out.writerIndex(bodyIndex + len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将 rpc 相关的信息写入，不采用直接写入 object 的方式是为了最大的降低数据传输的量</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">encodeRpcRequest</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RpcInfo</span> <span class="variable">info</span> <span class="operator">=</span> (RpcInfo) msg;</span><br><span class="line">    <span class="comment">// 请求的服务的名字</span></span><br><span class="line">    serializer.writeUTF(info.getServiceName());</span><br><span class="line">    <span class="comment">// 请求的方法名</span></span><br><span class="line">    serializer.writeUTF(info.getMethodName());</span><br><span class="line">    <span class="comment">// 请求的方法参数类型（用签名的方式表示）</span></span><br><span class="line">    serializer.writeUTF(ReflectUtils.getDesc(info.getPts()));</span><br><span class="line">    <span class="comment">// 方法调用的参数值</span></span><br><span class="line">    Object[] pvs = info.getPvs();</span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object pv : pvs) &#123;</span><br><span class="line">            serializer.writeObject(pv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将编码后的结果发送给服务端后，服务端会进行解码，然后根据解码的结果完成对应的服务接口实现类方法的调用，这个稍后进行说明，方法调用的结果，服务端也是通过 netty 发送回来，同样的数据包也是经过编码的，客户端需要对其进行解码，才能得到具体的结果，这个过程是在 <code>NettyDecoderHandler#decode</code> 方法中完成的，至于为什么是在这个方法，那么又需要涉及到 netty 的源码实现了。在该方法中，核心就是调用 <code>NettyDecoderHandler#prepareDecode</code> 方法，如果能够理解编码的过程，那么解码就是一个逆向过程，结合我在代码中的注释应该就能理解，这里也不再赘述.需要注意的是 <code>NettyDecoderHandler#prepareDecode</code> 方法解码出来的结果会在 <code>NettyDecoderHandler#decode</code> 中添加到 List&lt;Object&gt; out 集合中，然后在父类中会逐个的将里边的元素取出并交由下一个 ChannelHandler 处理，这里也就是我们在创建 NettyClient 时指定的 ClientFinalChannelHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (in.isReadable()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readerIndex</span> <span class="operator">=</span> in.readerIndex();</span><br><span class="line">        serializer = extensionSelector.deserializer(url, in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> count;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> prepareDecode(ctx, in, out);</span><br><span class="line">        <span class="keyword">if</span> (result == EMPTY_RESULT) &#123;</span><br><span class="line">            in.readerIndex(readerIndex);</span><br><span class="line">            count = pre;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> count - pre;</span><br><span class="line">            in.readerIndex(readerIndex + len);</span><br><span class="line">            out.add(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">prepareDecode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readable</span> <span class="operator">=</span> in.readableBytes();</span><br><span class="line">    <span class="type">byte</span>[] header = <span class="keyword">new</span> <span class="title class_">byte</span>[Math.min(readable, HEADER_LENGTH)];</span><br><span class="line">    in.readBytes(header);</span><br><span class="line">    <span class="comment">// 如果魔幻头不一致，那么就需要重新定位到新的魔幻头</span></span><br><span class="line">    <span class="keyword">if</span> ((readable &gt; <span class="number">0</span> &amp;&amp; header[<span class="number">0</span>] != MAGIC_LOW) || (readable &gt; <span class="number">1</span> &amp;&amp; header[<span class="number">1</span>] != MAGIC_HIGH)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> header.length;</span><br><span class="line">        <span class="keyword">if</span> (header.length &lt; readable) &#123; <span class="comment">// 这里说明够头部的长度</span></span><br><span class="line">            <span class="comment">// 这里就说明，除了 header 的字节部分，还有真正的数据部分</span></span><br><span class="line">            header = ByteUtils.copyOf(header, readable);</span><br><span class="line">            <span class="comment">// 这样就是将全部数据读到了 header 中，前 16 个为 header 部分，后边的为剩余数据</span></span><br><span class="line">            in.readBytes(header, length, readable - length);    <span class="comment">// 全部的数据都到了 header 中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; header.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (header[i] == MAGIC_LOW &amp;&amp; header[i + <span class="number">1</span>] == MAGIC_HIGH) &#123;    <span class="comment">// 这里是重新确定魔幻头的位置</span></span><br><span class="line">                <span class="comment">// 这里就说明又检测到了一个数据包，那么就将第一个数据包的内容放到 header 中</span></span><br><span class="line">                in.readerIndex(in.readerIndex() - header.length + i);   <span class="comment">// 将 readerIndex 重新定位到新的魔幻头位置</span></span><br><span class="line">                readable = in.readableBytes();</span><br><span class="line">                header = <span class="keyword">new</span> <span class="title class_">byte</span>[Math.min(readable, HEADER_LENGTH)];</span><br><span class="line">                in.readBytes(header);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次只解析一个数据包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length.</span></span><br><span class="line">    <span class="keyword">if</span> (readable &lt; HEADER_LENGTH) &#123; <span class="comment">// 接收到的数据还不足以解析出一个完整的数据包</span></span><br><span class="line">        <span class="keyword">return</span> EMPTY_RESULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get data length. 根据 header 获取 len 信息</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> ByteUtils.readInt(header, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">// 总长度为 header + 数据长度（header 后四位进行记录）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tt</span> <span class="operator">=</span> len + HEADER_LENGTH;</span><br><span class="line">    <span class="keyword">if</span> (readable &lt; tt) &#123;    <span class="comment">// 也就是说目前接受到的数据还不够 header + 包长度得到的总长度</span></span><br><span class="line">        <span class="keyword">return</span> EMPTY_RESULT;</span><br><span class="line">    &#125;</span><br><span class="line">    count += tt;</span><br><span class="line">    <span class="comment">// limit input stream.通过 ChannelBufferInputStream 对 buffer 进行封装，记录了内容读取的上下界</span></span><br><span class="line">    <span class="comment">// ChannelBufferInputStream -&gt; NettyBackedCahnnelBuffer -&gt; Netty 原生 buf</span></span><br><span class="line">    <span class="keyword">return</span> doDecode(header); <span class="comment">// 解码除开 header 以外的信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">doDecode</span><span class="params">(<span class="type">byte</span>[] header)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">flag</span> <span class="operator">=</span> header[<span class="number">2</span>], proto = (<span class="type">byte</span>) (flag &amp; SERIALIZER_MASK);</span><br><span class="line">    <span class="comment">// get request id.</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> ByteUtils.readLong(header, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 如果标志位是不是 request，那就说明是收到的 response</span></span><br><span class="line">    <span class="keyword">if</span> ((flag &amp; REQUEST_FLAG) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// decode response.</span></span><br><span class="line">        <span class="type">Response</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Response</span>(id);</span><br><span class="line">        <span class="comment">// get status.</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">status</span> <span class="operator">=</span> header[<span class="number">3</span>];</span><br><span class="line">        res.setStatus(status);</span><br><span class="line">        <span class="comment">// 判断当前相应是否为事件响应</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((flag &amp; EVENT_FLAG) == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.setType(MessageType.RESPONSE);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> serializer.readObject();</span><br><span class="line">                    res.setData(msg);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.setType(MessageType.HEARTBEAT_RESPONSE);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> serializer.readObject();</span><br><span class="line">                    res.setData(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Decode message error, please check provider and consumer use the same serializer&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清除 netty 原理的话就会知道在 ClientFinalChannelHandler 中接收上个 ChannelHandler 的处理结果的方法是 <code>ClientFinalChannelHandler#channelRead</code>，这个方法很简单，就只是向线程池中提交了一个 EventHandleThread 任务，它持有了解码出来的结果，那么接下来就是看这个 Task 对我们的解码结果做了什么处理。直接查看它的 run 方法。可以知道它就是直接调用 <code>handleMsg();</code>方法。因为我们收到的是服务端的 Response 数据包，所以只关注该方法的 <code>else if (msg instanceof Response)</code> 分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 处理接收到的消息，此处的处理怎么看都不够优雅</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InstantiationException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleMsg</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException &#123;</span><br><span class="line">    <span class="comment">// 这里是对于非事件 request 的处理方式</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> (Response) msg;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Received response message of &quot;</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">status</span> <span class="operator">=</span> response.getStatus();</span><br><span class="line">        <span class="comment">// 只对相应状态为 ok 的 response 进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (Response.OK == status) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> response.getData();</span><br><span class="line">            <span class="type">RpcResult</span> <span class="variable">result</span> <span class="operator">=</span> getRpcResult(response);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 完成相应结果的填充</span></span><br><span class="line">                result.fillData(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到所做的事情就是从 Response 中拿到响应的数据，然后将其填充到 RpcResult 中，特别注意，这个 RpcResult 是和 rpc Request 的 id 对应的，所以填充的结果也是针对对应的 RpcResult，而在 <code>RpcResult#fillData</code> 方法中，就是完成了结果的填充，并唤醒了阻塞在当前 rpc 请求对应的线程，这样 rpc 请求的结果就被服务接口客户端代理返回给接口的方法调用者。</p>
<h3 id="netty-通信服务端"><a href="#netty-通信服务端" class="headerlink" title="netty 通信服务端"></a>netty 通信服务端</h3><p>在服务端的启动中，我们也只是说了创建了 NettyServer，但是具体的细节没有进行说明，现在就完成这一部分的解释。和客户端一样，我们需要关注的是 ChannelInitializer 对于 NioSocketChannel 的初始化，方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 从 url 中获取 idleTimeout 时长，如果 url 参数中没有指定，那么就直接使用三倍的 heartBeat 时长</span></span><br><span class="line">        ch.pipeline()<span class="comment">//.addLast(&quot;logging&quot;,new LoggingHandler(LogLevel.INFO))//for debug</span></span><br><span class="line">                .addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">NettyDecoderHandler</span>(getUrl()))   <span class="comment">// InternalDecoder</span></span><br><span class="line">                .addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">NettyEncoderHandler</span>(getUrl()))   <span class="comment">// InternalEncoder</span></span><br><span class="line">                <span class="comment">// 用于检测 channel 空闲状态，条件成立时关闭对应的 channel，相对的客户端的 Idle 处理器则用于发送心跳消息</span></span><br><span class="line">                .addLast(<span class="string">&quot;server-idle-handler&quot;</span>, <span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">0</span>, IDLE_TIMEOUT, MILLISECONDS))</span><br><span class="line">                .addLast(<span class="string">&quot;heartbeat-handler&quot;</span>, <span class="keyword">new</span> <span class="title class_">HeartbeatHandler</span>())</span><br><span class="line">                .addLast(<span class="string">&quot;final-handler&quot;</span>, <span class="keyword">new</span> <span class="title class_">ServerFinalChannelHandler</span>(getUrl()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上文已经说过了前四个 ChannelHandler 的作用及使用了，服务端对于他们的使用基本一致，所以也不再赘述，最后一个 ChannelHandler 和 NettyClient 的最后一个 ChannelHandler 的作用基本一致，都是向线程池中提交了一个 EventHandleThread，里边的方法是一样的，只是因为处理的是来自客户端的 Request 包，所以走的是 <code>EventHandleThread#handleMsg</code> 方法的 <code>if (msg instanceof Request)</code> 分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是对于非事件 request 的处理方式</span></span><br><span class="line"><span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request) msg;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Received request message of &quot;</span> + request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!request.isEvent()) &#123;</span><br><span class="line">        <span class="comment">// 根据 request 相关的内容构建 response</span></span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> buildResponse(request);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> request.getData();</span><br><span class="line">        <span class="comment">// 如果 request 携带的数据为 RpcInfo，那么就根据其进行相应的 invoker 调用</span></span><br><span class="line">        <span class="keyword">if</span> (data <span class="keyword">instanceof</span> RpcInfo) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> doInvoke((RpcInfo) data);</span><br><span class="line">            <span class="comment">// 将 invoke 的结果填充到 response 中</span></span><br><span class="line">            response.setData(result);</span><br><span class="line">            <span class="comment">// 将响应结果写回</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据 RpcInfo 进行逻辑调用，获取调用的结果</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InstantiationException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">doInvoke</span><span class="params">(RpcInfo data)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">RpcInfo</span> <span class="variable">info</span> <span class="operator">=</span> data;</span><br><span class="line">    <span class="comment">// 尝试从 BeehiveContext 中获取 invoker 实例</span></span><br><span class="line">    <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> BeehiveContext.unsafeGet(info.getServiceName(), Invoker.class);</span><br><span class="line">    <span class="comment">// 根据 url 信息获取 invoke target 实例</span></span><br><span class="line">    <span class="type">ServiceConfigBean</span> <span class="variable">serviceConfigBean</span> <span class="operator">=</span> BeehiveContext.unsafeGet(UrlConstants.PROVIDER_MODEL, ServiceConfigBean.class);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> serviceConfigBean.getRef();</span><br><span class="line">    <span class="comment">// 进行真正的 invoke 操作</span></span><br><span class="line">    <span class="keyword">return</span> invoker.invoke(info.createInvokeInfo(target));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在该分支中，首先是构建了一个 Response 实例，这个实例的 id 是和 Request 一致的，这样客户端收到该 Response 数据包后才知道对应哪个 RpcResult 实例。接下来，就是从收到的 Request 中拿到数据 RpcInfo，里边包含了 rpc 的服务名、方法名、参数类型签名、参数值。<code>EventHandleThread#doInvoke</code> 方法就是根据以上这些进行服务接口实现类方法的调用。可以看到它先从 BeehiveContext 中拿到了一个 Invoker 实例，其实它就是在服务端启动时创建的 Invoker 链。其最后一个节点就封装了服务接口的实现类。当我们进行 invoker 链的 invoke 方法调用时，最终就会触发服务接口的实现类对应方法的调用，返回的就是该方法的执行结果。拿到该结果后，就是将它填充到 Response 实例中，调用 <code>tx.writeAndFlush(response);</code> 将响应结果返回，这样一个完成的 rpc 过程就算完成了。</p>
<h2 id="TODO-LIST"><a href="#TODO-LIST" class="headerlink" title="TODO-LIST"></a>TODO-LIST</h2><ul>
<li><p>底层通信框架的支持有待完善，比如 Mina（我没接触过）</p>
</li>
<li><p>缺少一个服务的管理模块，框架当前提供了相应的 filter 接口，通过实现该接口即可对 rpc 请求进行拦截，由此来获取部分监控信息</p>
</li>
<li><p>SPI 拓展机制没有完成相应的组件筛选功能，比如 filter 接口实现类，框架没有提供基础的选择性获取方式</p>
</li>
<li><p>异步消息处理的线程池的构建应该更加灵活，相应的拒绝执行策略有待完善</p>
</li>
<li><p>负载均衡策略缺陷严重，应该需要根据实际的 provider 负载情况来动态的调整</p>
</li>
</ul>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/RPC/">#RPC</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2019/07/21/2019-07-21-Spring-AOP-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Spring AOP 实现原理分析</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2019/07/17/2019-07-17-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%9F%E4%B8%80id%E7%94%9F%E6%88%90%E5%99%A8snowflake%E4%BB%8B%E7%BB%8D/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">分布式统一id生成器snowflake介绍</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">小橘子🍊</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">功能特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">使用方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="nav-number">4.</span> <span class="nav-text">参数设置说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lt-beehive-service-x2F-gt-%E6%A0%87%E7%AD%BE"><span class="nav-number">4.1.</span> <span class="nav-text">&lt;beehive:service&#x2F;&gt; 标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt-beehive-reference-x2F-gt-%E6%A0%87%E7%AD%BE"><span class="nav-number">4.2.</span> <span class="nav-text">&lt;beehive:reference&#x2F;&gt; 标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt-beehive-registry-x2F-gt-%E6%A0%87%E7%AD%BE"><span class="nav-number">4.3.</span> <span class="nav-text">&lt;beehive:registry&#x2F;&gt; 标签</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E6%B5%8B%E8%AF%95"><span class="nav-number">5.</span> <span class="nav-text">样例测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%8B%E8%AF%95"><span class="nav-number">5.1.</span> <span class="nav-text">基本测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%88%87%E6%8D%A2%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-number">5.2.</span> <span class="nav-text">服务切换的测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">底层实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE%E8%A7%A3%E6%9E%90"><span class="nav-number">6.1.</span> <span class="nav-text">标签解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8"><span class="nav-number">6.2.</span> <span class="nav-text">服务端启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8"><span class="nav-number">6.3.</span> <span class="nav-text">客户端启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-RPC-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="nav-number">6.4.</span> <span class="nav-text">客户端 RPC 请求流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netty-%E9%80%9A%E4%BF%A1%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">6.5.</span> <span class="nav-text">netty 通信客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netty-%E9%80%9A%E4%BF%A1%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">6.6.</span> <span class="nav-text">netty 通信服务端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TODO-LIST"><span class="nav-number">7.</span> <span class="nav-text">TODO-LIST</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
