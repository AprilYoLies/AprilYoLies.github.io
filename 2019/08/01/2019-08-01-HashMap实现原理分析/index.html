<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Java 后端">
    <meta name="description" content="小橘子🍊的个人主页，欢迎访问~~">
    <meta name="author" content="小橘子🍊">
    
    <title>
        
            HashMap实现原理分析 |
        
        AprilYoLies
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://img.aprilyolies.top/img/typora/avatar.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"aprilyolies.top","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"https://img.aprilyolies.top/img/typora/avatar.jpg","favicon":"https://img.aprilyolies.top/img/typora/avatar.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"干燥的空气，尘埃的味道，我在其中…踏上旅途！"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://img.aprilyolies.top/img/typora/avatar.jpg">
                </a>
            
            <a class="logo-title" href="/">
                AprilYoLies
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">HashMap实现原理分析</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="https://img.aprilyolies.top/img/typora/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">小橘子🍊</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2019-08-01 11:18:30</span>
        <span class="mobile">2019-08-01 11:18</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Java/">Java</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是关于 HashMap 实现原理的分析文章，网上关于 HashMap 实现原理分析的文章已经足够多了，所以我这里写这篇文章仅仅是对自己看过的那些文章进行汇总，方便自己以后进行查阅。</p>
<p>本文大部分内容转载自思否作者 <code>ChiuCheng</code> <a class="link"   target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015796727" >深入理解HashMap<i class="fas fa-external-link-alt"></i></a> 系列文章，感谢大佬，另外他写的其他几篇文章也十分值得阅读。</p>
<h2 id="HashMap-解决了什么问题"><a href="#HashMap-解决了什么问题" class="headerlink" title="HashMap 解决了什么问题"></a>HashMap 解决了什么问题</h2><p>任何数据结构的产生总对应着要解决一个实际的问题，HashMap的产生要解决问题就是：如何有效的 存&#x2F;取 一组 key-vaule 键值对。key-value 键值对是最常使用的数据形式，如何有效地存取他们是众多语言都需要关注的问题。注意这里有四个关键字如下，下面我们逐个来思考。</p>
<ol>
<li><p>key-value键值对</p>
</li>
<li><p>一组</p>
</li>
<li><p>存</p>
</li>
<li><p>取</p>
</li>
</ol>
<h2 id="如何表示-key-value-键值对"><a href="#如何表示-key-value-键值对" class="headerlink" title="如何表示 key-value 键值对"></a>如何表示 key-value 键值对</h2><p>在java这种面向对象的语言中，表示一个数据结构自然要用到类，由于对于键值对的数据类型事先并不清楚，显而易见这里应该要用泛型，则表示key-value键值对最简单的形式可以是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;K，V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们自定义一个 Node 类，它只有两个属性，一个 key 属性表示键，一个 value 属性表示值，则这个类就代表了一个 key-value 键值对。</p>
<p>当然，我们还需要定义一些方法来操纵这两个属性，例如 get 和 set 方法等，不过根据设计原则，我们应该面向接口编程，所以应该定义一个接口来描述需要执行的操作，这个接口就是 Entry&lt;K，V&gt;，它只不过是对于 Node&lt;K，V&gt; 这个类的抽象，在 java 中，这个接口定义在 Map 这个接口中，所以上面的类可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;K，V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>。Entry&lt;K，V&gt;&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们总结一下，我们定义了一个Node类来表示一个键值对，为了面向接口编程，我们抽象出一个 Entry 接口，并使 Node 类实现了这个接口。至于这个接口需要定义哪些方法，我们暂不细表。这样，我们完成了对于 key-value 键值对的表示。</p>
<h2 id="如何存储-key-value-键值对"><a href="#如何存储-key-value-键值对" class="headerlink" title="如何存储 key-value 键值对"></a>如何存储 key-value 键值对</h2><p>在常见的业务逻辑中，我们常常需要处理一组键值对的集合，将一组键值对存储在一处，并根据 key 值去查找对应的 value 。那么我们要如何存储这些键值对的集合呢?其实换个问法可能更容易回答，应该怎样存储一组对象?(毕竟键值对已经被我们表示为 Node 对象了)，在 java 中，存储一个对象的集合无外乎两种方式：数组或者链表，关于数组和链表的优缺点大家已经耳熟能详了：</p>
<ul>
<li><p>数组大小有限，查找性能好，插入和删除性能差</p>
</li>
<li><p>链表大小不限，查找性能差，插入和删除性能好</p>
</li>
</ul>
<p>这里应该选哪种形式呢？那得看实际的应用了，在使用键值对时，查找和插入，删除等操作都会用到，但是在实际的应用场景中，对于键值对的查找操作居多，所以我们当然选择数组形式，在 HashMap 中该数组被表示为：</p>
<blockquote>
<p>Node&lt;K,V&gt;[] table;</p>
</blockquote>
<p>总结：我们选择数组形式来存储 key-value 对象。为了便于下文描述，我们将数组的下标称为索引(index)，将数组中的一个存储位置称为数组的一个存储桶(bucket)。</p>
<h2 id="如何有效地根据key值查找value"><a href="#如何有效地根据key值查找value" class="headerlink" title="如何有效地根据key值查找value"></a>如何有效地根据key值查找value</h2><p>前面已经讲到，我们选择数组形式来存储 key-value 对象，以利用其优良的查找性能，数组之所以查找迅速，是因为可以根据索引(数组下标)直接定位到对应的存储桶(数组所存储对象的位置)。但是实际应用中，我们都是通过 key 值来查找 value 值，怎么办呢？</p>
<p>一种方式就是遍历数组中的每一个对象，查看它的 key 是不是我们要找的key，但是很明显，这种方式效率低下(而且这不就是链表的顺序查找方式吗？) 完全违背了我们选择数组来存储键值对的初衷。</p>
<p>为了利用索引来查找，我们需要建立一个 key -&gt; index 的映射关系，这样每次我们要查找一个 key 时，首先根据映射关系，计算出对应的数组下标，然后根据数组下标，直接找到对应的 key-value 对象，这样基本能以 o(1) 的时间复杂度得到结果。</p>
<p>这里，将 key 映射成 index 的方法称为hash算法，我们希望它能将 key 均匀的分布到数组中。</p>
<p>这里插一句，使用 Hash 算法同样补足了数组插入和删除性能差的短板，我们知道，数组之所以插入删除性能差是因为它是顺序存储的，在一个位置插入节点或者删除节点需要一个个移动它的后续节点来腾出位或者覆盖位置。使用hash算法后，数组不再按顺序存储，插入删除操作只需要关注一个存储桶即可，而不需要额外的操作。</p>
<h2 id="如何解决hash冲突"><a href="#如何解决hash冲突" class="headerlink" title="如何解决hash冲突"></a>如何解决hash冲突</h2><p>这个问题其实是由上一个问题引出的，虽然我们要求 hash 算法能将 key 均匀的分布到数组中，但是它只能尽量做到，并不是绝对的，更何况我们的数组大小是有限的，保不齐我们的 hash 算法将就两个不同的 key 映射成了同一个 index 值，这就产生了 hash 冲突，也就是两个 Node 要存储在数组的同一个位置该怎么办?</p>
<p>解决hash冲突的方法有很多，在 HashMap 中我们选择链地址法，即在产生冲突的存储桶中改为单链表存储。此外还有一些其它的用于解决 hash 冲突的的办法如下，详细的请参考文章 <a class="link"   target="_blank" rel="noopener" href="https://blog.51cto.com/yiluohuanghun/1305172" >解决哈希（HASH）冲突的主要方法<i class="fas fa-external-link-alt"></i></a>。</p>
<ul>
<li><p>开放地址法：线性探查法、线性补偿探测法 、随机探测 </p>
</li>
<li><p>拉链法：HashMap 即采用该方式</p>
</li>
</ul>
<p>其实，最理想的效果是，Entry 数组中每个位置都只有一个元素，这样查询的时候效率最高，不需要遍历单链表，也不需要通过equals 去比较 Key，而且空间利用率最大。链地址法使我们的数组转变成了链表的数组，其结构如下：</p>
<div style="text-align:center;"><img src="https://image.aprilyolies.top/static/images/common/452ffc469f9b34b7598b49a04ceba8e7.jpg" width=600 /></div>

<center>HashMap 的数组加链表结构</center>

<p>

<p>至此，我们对key-value键值对的表示变为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    </span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表长度过长怎么办"><a href="#链表长度过长怎么办" class="headerlink" title="链表长度过长怎么办"></a>链表长度过长怎么办</h2><p>我们知道，链表查找只能通过顺序查找来实现，因此，时间复杂度为 o(n)，如果很不巧，我们的 key 值被 Hash 算法映射到一个存储桶上，将会导致存储桶上的链表长度越来越长，此时，数组查找退化成链表查找，则时间复杂度由原来的 o(1) 退化成 o(n)。</p>
<p>为了解决这一问题，在 java8 中，当链表长度超过 8 之后，将会自动将链表转换成红黑树，以实现 o(log n) 的时间复杂度，从而提升查找性能。</p>
<div style="text-align:center;"><img src="https://image.aprilyolies.top/static/images/common/7f714e97d8ecdf37bbaba1e52aeffff3.jpg" width=600 /></div>

<center>HashMap 的数组加链表或者红黑树结构</center>

<p>

<h2 id="什么时候扩容"><a href="#什么时候扩容" class="headerlink" title="什么时候扩容"></a>什么时候扩容</h2><p>前面已经说到，数组的大小是有限的，在新建的时候就要指定，如果加入的节点已经到了数组容量的上限，已经没有位置能够存储 key-value 键值对了，此时就需要扩容。</p>
<p>但是很明显，我们不会等到火烧眉毛了才想起来要扩容，在实际的应用中，数组空间已使用 3&#x2F;4 之后，我们就会括容。为什么是0.75呢，官方文档的解释是：</p>
<blockquote>
<p>the default load factor (.75) offers a good tradeoff between time and space costs.</p>
</blockquote>
<p>再说回扩容，有的同学就要问了，咱上面不是将数组的每一个元素转变成链表了吗? 就算此时节点数超过了数组大小，新加的节点会存在数组某一个位置的链表里啊，链表的大小不限，可以存储任意数量的节点啊！</p>
<p>没错，理论上来说这样确实是可行的，但这又违背了我们一开始使用数组来存储一组键值对的初衷，还记得我们选择数组的原因是什么吗？为了利用索引快速的查找！如果我们试图指望利用链表来扩容的话，当一个存储桶的中的链表越来越大，在这个链表上的查找性能就会很差(退化成顺序查找了)，为此，在数组容量不足时，为了继续维持利用数组索引查找的优良性能，我们必须对数组进行扩容。</p>
<h2 id="每次扩容扩多大"><a href="#每次扩容扩多大" class="headerlink" title="每次扩容扩多大"></a>每次扩容扩多大</h2><p>我们知道，数组的扩容是一个很耗费 CPU 资源的动作，需要将原数组的内容复制到新数组中去，因此频繁的扩容必然会导致性能降低，所以不可能数组满了之后，每多加一个 node，我们就扩容一次。</p>
<p>但是，一次扩容太大，导致大量的存储空间用不完，势必又造成很大的浪费，因此，必须根据实际情况设定一个合理的扩容大小。在 HashMap 的实现中，每次扩容我们都会将新数组的大小设为原数组大小的两倍。</p>
<h2 id="Hash-算法原理"><a href="#Hash-算法原理" class="headerlink" title="Hash 算法原理"></a>Hash 算法原理</h2><p>为了利用数组索引进行快速查找，我们需要先将 key 值映射成数组下标。因为数组的下标是有限的集合，所以我们可以先通过 hash 算法将 key 映射成整数，再将整数映射成有限的数组下标，即 Object -&gt; int -&gt; index。</p>
<p>对于 Object -&gt; int 部分，使用的就是 hash function，而对于 int -&gt; index 部分，我们可以简单的使用对数组大小取模来实现。在 java 中，hash 函数是一个 native 方法，这个方法定义在 Object 类中，所以所有的对象都会继承。因为这是一个本地方法，所以我们无法看到它的具体实现，但是从函数签名上可以看出，该方法将任意对象映射成一个整型值。调用该方法，我们就完成了 Object -&gt; int的映射。</p>
<p>所以将 key 映射成 index 的方式可以是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key.hashCode() % table.length</span><br></pre></td></tr></table></figure>

<p>那么 HashMap 是这样做的吗？事实上，HashMap 定义了自己的散列方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道 int 类型是 32 位的，h ^ h &gt;&gt;&gt; 16 其实就是将 hashCode 的高 16 位和低 16 位进行异或，这充分利用了高半位和低半位的信息，对低位进行了扰动，目的是为了使该 hashCode 映射成数组下标时可以更均匀。另外从这个函数中，我们还可以得到一个意外收获：HashMap 中 key 值可以为 null，且 null 值一定存储在数组的第一个位置。</p>
<p>前面我们提到，将 hash 值转换成数组下标我们可以采用取模运算，但是取模运算是十分耗时的。另一方面，我们知道，当一个数是 2^n 时，任意整数对2^n取模等效于:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h % <span class="number">2</span>^n = h &amp; (<span class="number">2</span>^n -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这样我们就将取模操作转换成了位操作，而位操作的速度远远快于取模操作。因此在 HashMap 中，table 的大小都是 2 的 n 次方大小，即使你在构造函数中指定了 table 的大小，HashMap 也会将该值扩大为距离它最近的 2 的整数次幂的值. 这在我们下面分析构造函数的时候就能看到了。</p>
<h2 id="HashMap-构造函数"><a href="#HashMap-构造函数" class="headerlink" title="HashMap 构造函数"></a>HashMap 构造函数</h2><p>HashMap 共有四个构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认初始大小 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认负载因子 0.75</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line">    <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">    <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 没有指定时, 使用默认值</span></span><br><span class="line">    <span class="comment">// 即默认初始大小16, 默认负载因子 0.75</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定初始大小, 但使用默认负载因子</span></span><br><span class="line">    <span class="comment">// 注意这里其实是调用了另一个构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定初始大小和负载因子</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用已经存在的map创建HashMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码我们知道，即使我们在构造函数中指定了 initialCapacity，这个值也只被用来计算 threshold，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure>

<p>而 threshold 这个值在初始化 table 时，就代表了数组的初始大小，我们看看 <code>tableSizeFor</code> 函数的实现，可以知道它就是得到了大于等于参数的最小的 2 的幂级数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来看最后一个构造函数，它调用了 putMapEntries 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，当使用构造函数HashMap(Map&lt;? extends K，? extends V&gt; m) 时，我们并没有为 table 赋值，所以，table 值一定为null，我们先根据传入 Map 的大小计算 threshold 值，然后判断需不需要扩容，最后调用 putVal 方法将传入的 Map 插入 table 中。</p>
<h2 id="HashMap-的-resize-扩容"><a href="#HashMap-的-resize-扩容" class="headerlink" title="HashMap 的 resize 扩容"></a>HashMap 的 resize 扩容</h2><p>resize 用于以下两种情况之一：</p>
<ul>
<li><p>初始化table</p>
</li>
<li><p>在table大小超过threshold之后进行扩容</p>
</li>
</ul>
<p>下面我们直接来对照源码分析:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原table中已经有值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 已经超过最大限制, 不再扩容, 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意, 这里扩容是变成原来的两倍</span></span><br><span class="line">        <span class="comment">// 但是有一个条件: `oldCap &gt;= DEFAULT_INITIAL_CAPACITY`</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)    <span class="comment">// DEFAULT_INITIAL_CAPACITY 为 16</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在构造函数一节中我们知道</span></span><br><span class="line">    <span class="comment">// 如果没有指定initialCapacity, 则不会给threshold赋值, 该值被初始化为0</span></span><br><span class="line">    <span class="comment">// 如果指定了initialCapacity, 该值被初始化成大于initialCapacity的最小的2的次幂</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是指, 如果构造时指定了initialCapacity, 则用threshold作为table的实际大小</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果构造时没有指定initialCapacity, 则用默认值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算指定了initialCapacity情况下的新的 threshold</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从以上操作我们知道, 初始化HashMap时, </span></span><br><span class="line">    <span class="comment">//如果构造函数没有指定initialCapacity, 则table大小为16</span></span><br><span class="line">    <span class="comment">//如果构造函数指定了initialCapacity, 则table大小为threshold, 即大于指定initialCapacity的最小的2的整数次幂</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从下面开始, 初始化table或者扩容, 实际上都是通过新建一个table来完成的</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这段就是把原来table里面的值全部搬到新的table里面</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里注意, table中存放的只是Node的引用, 这里将oldTab[j]=null只是清除旧表的引用, 但是真正的node节点还在, 只是现在由e指向它</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果该存储桶里面只有一个bin, 就直接将它放到新表的目标位置</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果该存储桶里面存的是红黑树, 则拆分树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//红黑树的部分以后有机会再讲吧</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 下面这段代码很精妙, 我们单独分一段详细来讲</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们单独来看看这段设计的很精妙的代码，首先是定义了四个 Node 的引用，从变量命名上，我们初步猜测，这里定义了两个链表，我们把它称为 lo 链表 和 hi 链表， loHead 和 loTail 分别指向 lo 链表的头节点和尾节点， hiHead 和 hiTail 以此类推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>接着是一个 do while 循环代码块如下，其逻辑很简单就是按顺序遍历该存储桶位置上的链表中的节点。如果 (e.hash &amp; oldCap) &#x3D;&#x3D; 0，我们就将该节点放入 lo 链表，否则放入 hi 链表。如果 lo 链表非空，我们就把整个 lo 链表放到新 table 的 j 位置上，如果 hi 链表非空, 我们就把整个 hi 链表放到新 table 的 j+oldCap 位置上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>综上我们知道，这段代码的意义就是将原来的链表拆分成两个链表，并将这两个链表分别放到新的 table 的 j 位置和 j+oldCap 上, j 位置就是原链表在原 table 中的位置，拆分的标准就是下边的代码，具体的过程可以通过下边的示意图进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(e.hash &amp; oldCap) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<div style="text-align:center;"><img src="https://image.aprilyolies.top/static/images/common/a64f249f17673c528b8c07f554033c91.jpg" width=600 /></div>

<center>HashMap resize 过程链表拆分示意图</center>

<p>

<p>关于两个链表的存放位置，可能会有些疑惑，为什么一定是 j 和 j+oldCap 这两个位置呢？</p>
<p>我们假设 oldCap &#x3D; 16，即 2^4，16 - 1 &#x3D; 15，二进制表示为 <code>0000 0000 0000 0000 0000 0000 0000 1111</code> 可见除了低 4 位，其他位置都是 0（简洁起见，高位的 0 后面就不写了），则 (16-1) &amp; hash 自然就是取 hash 值的低 4 位，我们假设它为 abcd。</p>
<p>以此类推，当我们将 oldCap 扩大两倍后，新的 index 的位置就变成了 (32-1) &amp; hash，其实就是取 hash 值的低 5 位. 那么对于同一个 Node，低 5 位的值无外乎下面两种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0abcd</span><br><span class="line">1abcd</span><br></pre></td></tr></table></figure>

<p>其中，0abcd 与原来的 index 值一致，而 1abcd &#x3D; 0abcd + 10000 &#x3D; 0abcd + oldCap，故虽然数组大小扩大了一倍，但是同一个 key 在新旧 table 中对应的 index 却存在一定联系：要么一致，要么相差一个 oldCap。</p>
<p>而新旧index是否一致就体现在 hash 值的第 4 位(我们把最低为称作第 0 位)，怎么拿到这一位的值呢，只要通过下边这个计算表达式即可，即 hash &amp; oldCap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash &amp; <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure>

<p>因此可以有如下结论：</p>
<blockquote>
<p>如果 (e.hash &amp; oldCap) &#x3D;&#x3D; 0 则该节点在新表的下标位置与旧表一致都为 j</p>
</blockquote>
<blockquote>
<p>如果 (e.hash &amp; oldCap) &#x3D;&#x3D; 1 则该节点在新表的下标位置 j + oldCap</p>
</blockquote>
<h2 id="HashMap-的-put-方法"><a href="#HashMap-的-put-方法" class="headerlink" title="HashMap 的 put 方法"></a>HashMap 的 put 方法</h2><p>put 方法在接口中的定义为，第一个参数为 key 所对应的 hash 值，key 和 value 代表我们要进行存储的键值对。第四个参数 onlyIfAbsent 用于决定待存储的 key 已经存在的情况下，要不要用新值覆盖原有的value，如果为true，则保留原有值，false 则覆盖原有值，从下边的调用看，该值为false，说明当key值已经存在时，会直接覆盖原有值。最后一个参数 evict 用来区分当前是否是构造模式，我们在讲解构造函数的时候曾经提到，HashMap 的第四个构造函数可以通过已经存在的 Map 初始化一个 HashMap，如果为 false，说明在构造模式下，这里我们是用在 put 函数而不是构造函数里面，所以为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/*final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>putVal 方法的具体实现如下，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先判断table是否是空的</span></span><br><span class="line">    <span class="comment">// 我们知道, HashMap的三个构造函数中, 都不会初始Table, 因此第一次put值时, table一定是空的, 需要初始化</span></span><br><span class="line">    <span class="comment">// table的初始化用到了resize函数, 这个我们上一篇文章已经讲过了</span></span><br><span class="line">    <span class="comment">// 由此可见table的初始化是延迟到put操作中的</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 这里利用 `(n-1) &amp; hash` 方法计算 key 所对应的下标</span></span><br><span class="line">    <span class="comment">// 如果key所对应的桶里面没有值, 我们就新建一个Node放入桶里面</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到这里说明目标位置桶里已经有东西了</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 这里先判断当前待存储的key值和已经存在的key值是否相等</span></span><br><span class="line">        <span class="comment">// key值相等必须满足两个条件</span></span><br><span class="line">        <span class="comment">//    1. hash值相同</span></span><br><span class="line">        <span class="comment">//    2. 两者 `==` 或者 `equals` 等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">// key已经存在的情况下, e保存原有的键值对</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 到这里说明要保存的桶已经被占用, 且被占用的位置存放的key与待存储的key值不一致</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前面已经说过, 当链表长度超过8时, 会用红黑树存储, 这里就是判断存储桶中放的是链表还是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 红黑树的部分以后有机会再说吧</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//到这里说明是链表存储, 我们需要顺序遍历链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果已经找到了链表的尾节点了,还没有找到目标key, 则说明目标key不存在，那我们就新建一个节点, 把它接在尾节点的后面</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表的长度达到了8个, 就将链表转换成红黑数以提升查找性能</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在链表中找到了目标key则直接退出</span></span><br><span class="line">                <span class="comment">// 退出时e保存的是目标key的键值对</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 到这里说明要么待存储的key存在, e保存已经存在的值</span></span><br><span class="line">        <span class="comment">// 要么待存储的key不存在, 则已经新建了Node将key值插入, e的值为Null</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果待存储的key值已经存在</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 前面已经解释过, onlyIfAbsent的意思</span></span><br><span class="line">            <span class="comment">// 这里是说旧值存在或者旧值为null的情况下, 用新值覆盖旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">//这个函数只在LinkedHashMap中用到, 这里是空函数</span></span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到这里说明table中不存在待存储的key, 并且我们已经将新的key插入进数组了</span></span><br><span class="line">    </span><br><span class="line">    ++modCount; <span class="comment">// 这个暂时用不到</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为又插入了新值, 所以我们得把数组大小加1, 并判断是否需要重新扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict); <span class="comment">//这个函数只在LinkedHashMap中用到, 这里是空函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put 函数的总结就是：</p>
<ul>
<li><p>在 put 之前会检查 table 是否为空，这说明 table 真正的初始化并不是发生在构造函数中，而是发生在第一次 put 的时候。</p>
</li>
<li><p>查找当前 key 是否存在的条件是 <code>p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))</code>。</p>
</li>
<li><p>如果插入的key值不存在，则值会插入到链表的末尾。</p>
</li>
<li><p>每次插入操作结束后，都会检查当前 table 节点数是否大于 threshold，若超过，则扩容。</p>
</li>
<li><p>当链表长度超过TREEIFY_THRESHOLD（默认是8）个时，会将链表转换成红黑树以提升查找性能。</p>
</li>
</ul>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Java/">#Java</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">#数据结构</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2019/07/25/2019-07-25-SpringMVC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">SpringMVC基本原理分析</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">小橘子🍊</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-text">HashMap 解决了什么问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA-key-value-%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-text">如何表示 key-value 键值对</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8-key-value-%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-text">如何存储 key-value 键值对</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E5%9C%B0%E6%A0%B9%E6%8D%AEkey%E5%80%BC%E6%9F%A5%E6%89%BEvalue"><span class="nav-text">如何有效地根据key值查找value</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81"><span class="nav-text">如何解决hash冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%E8%BF%87%E9%95%BF%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-text">链表长度过长怎么办</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A9%E5%AE%B9"><span class="nav-text">什么时候扩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E6%AC%A1%E6%89%A9%E5%AE%B9%E6%89%A9%E5%A4%9A%E5%A4%A7"><span class="nav-text">每次扩容扩多大</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-text">Hash 算法原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">HashMap 构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E7%9A%84-resize-%E6%89%A9%E5%AE%B9"><span class="nav-text">HashMap 的 resize 扩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E7%9A%84-put-%E6%96%B9%E6%B3%95"><span class="nav-text">HashMap 的 put 方法</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
